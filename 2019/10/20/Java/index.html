<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Java从基础到核心 | 蜗牛君</title>
  
  <meta name="keywords" content="IT民工,技术干货,避坑指南">
  
  
  <meta name="description" content="这是一篇关于Java的综合知识整理">
  

  

  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css">
  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.9.9/css/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  
  <div class="cover-wrapper">
    <cover class='cover post half'>
      
        
  <h1 class='title'>蜗牛君的NoteBook</h1>


  <div class="m_search">
    <form name="searchform" class="form u-search-form">
      <input type="text" class="input u-search-input" placeholder="" />
      <i class="icon fas fa-search fa-fw"></i>
    </form>
  </div>

<div class='menu navgation'>
  <ul class='h-list'>
    
  </ul>
</div>

      
    </cover>
    <header class="l_header pure">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="pure"></div>
  </div>

	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href='/' >
        
          蜗牛君
        
      </a>
			<div class='menu navgation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="/"
                  
                  
                  id="home">
									<i class='fas fa-grin fa-fw'></i>&nbsp;示例
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/categories/"
                  
                    rel="nofollow"
                  
                  
                  id="categories">
									<i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/tags/"
                  
                    rel="nofollow"
                  
                  
                  id="tags">
									<i class='fas fa-hashtag fa-fw'></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/archives/"
                  
                    rel="nofollow"
                  
                  
                  id="archives">
									<i class='fas fa-archive fa-fw'></i>&nbsp;归档
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="Search" />
						<i class="icon fas fa-search fa-fw"></i>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a class="fas fa-search fa-fw" href='javascript:void(0)'></a></li>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/"
                
                
                id="home">
								<i class='fas fa-clock fa-fw'></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/archives/"
                
                  rel="nofollow"
                
                
                id="archives">
								<i class='fas fa-archive fa-fw'></i>&nbsp;文章归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/projects/"
                
                
                id="projects">
								<i class='fas fa-code-branch fa-fw'></i>&nbsp;开源项目
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/friends/"
                
                  rel="nofollow"
                
                
                id="friends">
								<i class='fas fa-link fa-fw'></i>&nbsp;我的友链
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="https://xaoxuu.com/wiki/material-x/"
                
                  rel="nofollow"
                
                
                id="https:xaoxuu.comwikimaterial-x">
								<i class='fas fa-book fa-fw'></i>&nbsp;主题文档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/"
                
                  rel="nofollow"
                
                
                id="about">
								<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于小站
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      <div class='l_main'>
  

  <article id="post" class="post white-box article-type-post" itemscope itemprop="blogPost">
    


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="/2019/10/20/Java/">
        Java从基础到核心
      </a>
    </h1>
  


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="/" rel="nofollow">
        
          <i class="fas fa-user" aria-hidden="true"></i>
        
        <p>蜗牛君</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-10-20</p>
  </a>
</div>

          
        
          
            

          
        
          
            
  
    <div class="new-meta-item browse busuanzi">
      <a class='notlink'>
        <i class="fas fa-eye" aria-hidden="true"></i>
        <p>
          <span id="busuanzi_value_page_pv">
            <i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i>
          </span>
        </p>
      </a>
    </div>
  


          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


    <section class="article typo">
      <div class="article-entry" itemprop="articleBody">
        <h1 id="Java基础核心"><a href="/2019/10/20/Java/#Java基础核心" class="headerlink" title="Java基础核心"></a>Java基础核心</h1><h2 id="数据类型"><a href="/2019/10/20/Java/#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本类型"><a href="/2019/10/20/Java/#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul>
<li>byte/8</li>
<li>char/16</li>
<li>short/16</li>
<li>int/32</li>
<li>float/32</li>
<li>long/64</li>
<li>double/64</li>
<li>boolean/~</li>
</ul>
<h3 id="包装类型"><a href="/2019/10/20/Java/#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p> 基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="number">2</span>;     <span class="comment">// 装箱 调用了 Integer.valueOf(2)</span></span><br><span class="line"><span class="keyword">int</span> y = x;         <span class="comment">// 拆箱 调用了 X.intValue()</span></span><br></pre></td></tr></table></figure>

<h3 id="缓存池-重要"><a href="/2019/10/20/Java/#缓存池-重要" class="headerlink" title="缓存池(!!!重要)"></a>缓存池(!!!重要)</h3><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象；</li>
<li>Integer.valueOf(123) <strong>会使用缓存池中的对象</strong>，多次调用会取得同一个对象的引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line">Integer z = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">Integer k = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// trueCopy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p>
<p> <strong>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</strong>  编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。 </p>
<p> <strong>基本类型对应的缓冲池如下:</strong> </p>
<ul>
<li>boolean values true and false</li>
<li>all byte values (byte取值范围内的全部值 -128~127)</li>
<li>short values between -128 and 127</li>
<li>int values between -128 and 127</li>
<li>char in the range \u0000 to \u007F</li>
</ul>
<p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。</p>
<p>在 jdk 1.8 所有的数值类缓冲池中，<strong>Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=<size> 来指定这个缓冲池的大小</size></strong>，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。</p>
<h3 id="String-https-cyc2018-github-io-CS-Notes-notes-Java-基础-id-二、string"><a href="/2019/10/20/Java/#String-https-cyc2018-github-io-CS-Notes-notes-Java-基础-id-二、string" class="headerlink" title="[String](https://cyc2018.github.io/CS-Notes/#/notes/Java 基础?id=二、string)"></a>[String](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 基础?id=二、string)</h3><blockquote>
<p>String 被声明为 final，因此它不可被继承。(<strong>Integer</strong> 等包装类也不能被继承）</p>
<p>在 Java 8 中，String 内部使用 ** final byte[] 数组存储数据**。</p>
</blockquote>
<p><strong>内部实现:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    /** The value is used for character storage. */</span><br><span class="line">    private final byte[] value;//</span><br><span class="line"></span><br><span class="line">    /** The identifier of the encoding used to encode the bytes in &#123;@code value&#125;. */</span><br><span class="line">    private final byte coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>value数组被声明为final,这意味着<strong>value数组初始化之后就不能在引用其他数组</strong>,并且<strong>String内部没有改变value数组的方法</strong>,因此可以保证String不可变</p>
<h3 id="String-Pool"><a href="/2019/10/20/Java/#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h3><p> 字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line">String s3 = s1.intern();</span><br><span class="line">String s4 = s1.intern();</span><br><span class="line">System.out.println(s3 == s4);           <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="不可变的好处"><a href="/2019/10/20/Java/#不可变的好处" class="headerlink" title="不可变的好处"></a>不可变的好处</h3><ol>
<li><p><strong>1. 可以缓存 hash 值</strong></p>
<p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p>
<p><strong>2. String Pool 的需要</strong></p>
<p>如果一个 <strong>String 对象</strong>已经被<strong>创建过了</strong>，那么就<strong>会从 String Pool 中取得引用</strong>。只有 String 是不可变的，才可能使用 String Pool(否则可变的话,某个修改操作将导致所有引用该对象的值都发生改变)。</p>
<img src="/2019/10/20/Java//9112288f-23f5-4e53-b222-a46fdbca1603.png" alt="img" style="zoom:67%;">

</li>
</ol>
<h3 id="String-StringBuffer-and-StringBuilder"><a href="/2019/10/20/Java/#String-StringBuffer-and-StringBuilder" class="headerlink" title="String, StringBuffer and StringBuilder"></a>String, StringBuffer and StringBuilder</h3><p><strong>1. 可变性</strong></p>
<ul>
<li>String 不可变</li>
<li>StringBuffer 和 StringBuilder 可变</li>
</ul>
<p><strong>2. 线程安全</strong></p>
<ul>
<li>String 不可变，因此是线程安全的</li>
<li>StringBuilder 不是线程安全的</li>
<li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步  (几乎所有方法都用了synchronized关键字进行加锁)</li>
</ul>
<h2 id="运算"><a href="/2019/10/20/Java/#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="参数传递"><a href="/2019/10/20/Java/#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p><strong>!!!! Java 的参数是以值传递</strong>的形式传入方法中，而不是引用传递。</p>
<p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，<strong>本质</strong>上是将对象的<strong>地址以值</strong>的方式<strong>传递到形参</strong>中。因此在方法中使指针引用其它对象，那么这两个指针此时指向的是完全不同的对象，在一方改变其所指向对象的内容时对另一方没有影响。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassByValueExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog(<span class="string">"A"</span>);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        func(dog);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// A</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        dog = <span class="keyword">new</span> Dog(<span class="string">"B"</span>);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@74a14482</span></span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容 !!!</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PassByValueExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog(<span class="string">"A"</span>);</span><br><span class="line">        func(dog);</span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        dog.setName(<span class="string">"B"</span>);<span class="comment">//改变原地址指向的对象的值,所以原对象会受到影响</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="float与double"><a href="/2019/10/20/Java/#float与double" class="headerlink" title="float与double"></a>float与double</h3><p>Java 不能<strong>隐式执行向下转型</strong>，因为这会使得精度降低。</p>
<p>1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// float f = 1.1;</span></span><br><span class="line">        <span class="keyword">double</span> a=<span class="number">1.1</span>;</span><br><span class="line">        <span class="keyword">float</span> b=<span class="number">2.3f</span>;</span><br><span class="line">        <span class="keyword">double</span> v = <span class="number">32.32</span>d;</span><br></pre></td></tr></table></figure>

<p>1.1f 字面量才是 float 类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">1.1f</span>;</span><br></pre></td></tr></table></figure>

<h3 id="隐式类型转换"><a href="/2019/10/20/Java/#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// s1 = s1 + 1;</span></span><br></pre></td></tr></table></figure>

<p>但是使用 += 或者 ++ 运算符可以执行隐式类型转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 += <span class="number">1</span>;</span><br><span class="line"><span class="comment">// s1++;</span></span><br></pre></td></tr></table></figure>

<p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 = (<span class="keyword">short</span>) (s1 + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="switch"><a href="/2019/10/20/Java/#switch" class="headerlink" title="switch"></a>switch</h3><p>从 Java 7 开始，<strong>可以在 switch</strong> 条件判断语句<strong>中使用 String</strong> 对象。但是<strong>不支持Long !!!!</strong></p>
<h2 id="继承"><a href="/2019/10/20/Java/#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="权限修饰符"><a href="/2019/10/20/Java/#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><blockquote>
<p> Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示default包级可见 </p>
<p> 可以对<strong>类或类中的成员</strong>（字段以及方法）加上访问修饰符。 </p>
</blockquote>
<h3 id="重写与重载"><a href="/2019/10/20/Java/#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h3><p><strong>1. 重写（Override）</strong></p>
<blockquote>
<p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p>
</blockquote>
<p><strong>为了满足里式替换原则，重写有以下三个限制：</strong></p>
<ul>
<li><strong>子类</strong>方法的<strong>访问权限</strong>必须<strong>大于等于父类</strong>方法；  ==( 权限&gt;= )==</li>
<li><strong>子类</strong>方法的<strong>返回类型</strong>必须<strong>是父类方法返回类型或为其子类型</strong>。 ==( 返回类型相容 )==</li>
<li>子类方法<strong>抛出的异常类</strong>型必须<strong>是父类抛</strong>出<strong>异常</strong>类型或为其<strong>子类型</strong>。 <strong>(抛出异常相容)</strong></li>
</ul>
<p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。</p>
<p>下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：</p>
<ul>
<li><p>子类方法访问权限为 public，大于父类的 protected。</p>
</li>
<li><p>子类的返回类型为 ArrayList，是父类返回类型 List 的子类。</p>
</li>
<li><p>子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。</p>
</li>
<li><p>子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Integer&gt; <span class="title">func</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//子类重写的</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">func</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 重载（Overload）</strong></p>
<blockquote>
<p>重载<strong>只关心</strong>的是<strong>参数</strong>是否相同,而<strong>不关心返回值类型</strong> !!!!</p>
</blockquote>
<p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是<strong>参数类型、个数、顺序至少有一个不同</strong>。</p>
<p>应该注意的是，返回值不同，其它都相同不算是重载。</p>
</li>
</ul>
<h3 id="equals"><a href="/2019/10/20/Java/#equals" class="headerlink" title="equals()"></a>equals()</h3><blockquote>
<p>Object类中默认实现是比较两个对象的地址引用是否相等</p>
</blockquote>
<ul>
<li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li>
<li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li>
</ul>
<h3 id="hashCode"><a href="/2019/10/20/Java/#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><blockquote>
<p> hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。<strong>等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</strong>  </p>
<p>!!! <strong>所以hashCode是equals() 方法使用的前提</strong></p>
<p>所以重写equals方法一定要重写hashCode方法, 一般多用于hash环境下</p>
</blockquote>
<h3 id="toString-NaN"><a href="/2019/10/20/Java/#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>Object类原生实现: 类名+对象的hash值</p>
<h3 id="clone"><a href="/2019/10/20/Java/#clone" class="headerlink" title="clone()"></a>clone()</h3><blockquote>
<p> 使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。 </p>
</blockquote>
<p>Object类原生实现: 这个是一个protected方法, 必须要重写才能调用, 并且其<strong>原生实现是直接clone的对象的地址属于浅拷贝</strong></p>
<ul>
<li><p><strong>浅拷贝</strong></p>
<p>拷贝对象和原始对象的引用类型引用同一个对象。</p>
</li>
<li><p><strong>深拷贝</strong></p>
<p>拷贝对象和原始对象的引用类型引用不同对象。</p>
</li>
</ul>
<h3 id="super"><a href="/2019/10/20/Java/#super" class="headerlink" title="super"></a>super</h3><ul>
<li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，<strong>(子类不用super()显式调用的情况下)  一般是自动调用父类的默认构造函数</strong>，如果子类需要调用父类其它构造函数，那么就可以使用 super 函数。</li>
<li>访问父类的成员：如果子类重写了父类的某个方法，可以通过<strong>使用 super 关键字来引用父类的方法实现</strong>。</li>
</ul>
<h2 id="关键字"><a href="/2019/10/20/Java/#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="static"><a href="/2019/10/20/Java/#static" class="headerlink" title="static"></a>static</h3><p><strong>1. 静态变量</strong></p>
<ul>
<li>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。</li>
<li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;         <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> y;  <span class="comment">// 静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// int x = A.x;  // Non-static field 'x' cannot be referenced from a static context</span></span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="keyword">int</span> x = a.x;</span><br><span class="line">        <span class="keyword">int</span> y = A.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 静态方法</strong></p>
<blockquote>
<p>只能访问所属类的静态字段和静态方法( 这些属于类所有的, 而不是对象所有)，方法中不能有 this 和 super 关键字。</p>
</blockquote>
<p>静态方法在<strong>类加载的时候就存在了</strong>，它不依赖于任何实例。<strong>所以静态方法必须有实现</strong>，也就是说<strong>它不能是抽象方法</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// public abstract static void func2();  // Illegal combination of modifiers: 'abstract' and 'static'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 静态语句块</strong></p>
<p>静态语句块在<strong>类初始化时仅运行一次</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"123"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a1 = <span class="keyword">new</span> A();</span><br><span class="line">        A a2 = <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 静态内部类</strong></p>
<blockquote>
<p>非静态内部类依赖于外部类的实例，而静态内部类不需要。</p>
<p>静态内部类不能访问外部类的非静态的变量和方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context</span></span><br><span class="line">        OuterClass outerClass = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        InnerClass innerClass = outerClass.new InnerClass();</span><br><span class="line">        StaticInnerClass staticInnerClass = <span class="keyword">new</span> StaticInnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 静态导包</strong></p>
<p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xxx.ClassName.*</span><br></pre></td></tr></table></figure>

<p><strong>6. 初始化顺序</strong></p>
<p><strong>静态变量和静态语句块优先于实例变量和普通语句块</strong>，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String staticField = <span class="string">"静态变量"</span>;Copy to clipboardErrorCopied</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"静态语句块"</span>);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br><span class="line"><span class="keyword">public</span> String field = <span class="string">"实例变量"</span>;Copy to clipboardErrorCopied</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"普通语句块"</span>);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>最后才是构造函数的初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InitialOrderTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"构造函数"</span>);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>存在继承的情况下，初始化顺序为：</p>
<ul>
<li>父类（静态变量、静态语句块）</li>
<li>子类（静态变量、静态语句块）</li>
<li>父类（实例变量、普通语句块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量、普通语句块）</li>
<li>子类（构造函数）</li>
</ul>
<h2 id="反射"><a href="/2019/10/20/Java/#反射" class="headerlink" title="反射"></a>反射</h2><blockquote>
<p>==每个类都有一个 <strong>Class</strong> 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。==</p>
</blockquote>
<p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p>
<p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p>
<p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p>
<ul>
<li><strong>Field</strong> ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li>
<li><strong>Method</strong> ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li>
<li><strong>Constructor</strong> ：可以用 Constructor 的 newInstance() 创建新的对象。</li>
</ul>
<p><strong>反射的优点：</strong></p>
<ul>
<li><strong>可扩展性</strong> ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</li>
<li><strong>类浏览器和可视化开发环境</strong> ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</li>
<li><strong>调试器和测试工具</strong> ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</li>
</ul>
<p><strong>反射的缺点：</strong></p>
<p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</p>
<ul>
<li><p><strong>性能开销</strong> ：反射涉及了动态类型的解析，所以 <em>JVM 无法对这些代码进行优化</em>。因此，<strong>反射操作的效率要比那些非反射操作低得多</strong>。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</p>
</li>
<li><p><strong>安全限制</strong> ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</p>
</li>
<li><p><strong>内部暴露</strong> ：由于反射允许代码执行一些在正常情况下不被允许的操作（<strong>暴露了源码文件: 比如访问私有的属性和方法</strong>），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。<strong>反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化</strong>。</p>
</li>
<li><p><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html">Trail: The Reflection API</a></p>
</li>
<li><p><a href="http://www.sczyh30.com/posts/Java/java-reflection-1/">深入解析 Java 反射（1）- 基础</a></p>
</li>
</ul>
<h3 id="抽象类与接口"><a href="/2019/10/20/Java/#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h3><p><strong>1. 抽象类</strong></p>
<p>抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。</p>
<p>抽象类和普通类最大的区别是，<strong>抽象类不能被实例化，需要继承抽象类才能实例化其子类</strong>。</p>
<p><strong>2. 接口</strong></p>
<p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。<strong>从 Java 8 开始，接口也可以拥有默认的方法实现</strong>，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。</p>
<p>接口的成员（字段 + 方法）默认都是 public 的，并且<strong>不允许定义为 private 或者 protected  (因为接口必须被实现)</strong>。</p>
<p>接口的<strong>字段默认都是 static 和 final 的</strong>。</p>
<p><strong>3. 比较</strong></p>
<ul>
<li>从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li>
<li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li>
<li><strong><em>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</em></strong></li>
<li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li>
</ul>
<p><strong>4. 使用选择</strong></p>
<p>使用接口：</p>
<ul>
<li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；</li>
<li>需要使用多重继承。</li>
</ul>
<p>使用抽象类：</p>
<ul>
<li>需要在几个相关的类中共享代码。</li>
<li>需要能控制继承来的成员的访问权限，而不是都为 public。</li>
<li>需要继承非静态和非常量字段。</li>
</ul>
<p>在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p>
<h2 id="异常"><a href="/2019/10/20/Java/#异常" class="headerlink" title="异常"></a>异常</h2><p><strong>Throwable 可以用来表示任何可以作为异常抛出的类</strong>,是所有异常的基类，分为两种： <strong>Error</strong> 和 <strong>Exception</strong>。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：</p>
<ul>
<li><strong>受检异常</strong> ：需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复；</li>
<li><strong>非受检异常</strong> ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</li>
</ul>
<img src="/2019/10/20/Java//PPjwP.png" alt="img" style="zoom: 67%;">

<h2 id="泛型"><a href="/2019/10/20/Java/#泛型" class="headerlink" title="泛型"></a>泛型</h2><blockquote>
<p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，<strong>通过泛型指定的不同类型来控制形参具体限制的类型</strong>）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>
</blockquote>
<h3 id="泛型类"><a href="/2019/10/20/Java/#泛型类" class="headerlink" title="泛型类:"></a>泛型类:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// T stands for "Type"</span></span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">this</span>.t = t; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型接口"><a href="/2019/10/20/Java/#泛型接口" class="headerlink" title="泛型接口:"></a>泛型接口:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span></span><br><span class="line"><span class="comment"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错："Unknown class"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型方法"><a href="/2019/10/20/Java/#泛型方法" class="headerlink" title="泛型方法:"></a>泛型方法:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法的基本介绍</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tClass 传入的泛型实参</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment"> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment"> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment"> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">genericMethod</span><span class="params">(Class&lt;T&gt; tClass)</span><span class="keyword">throws</span> InstantiationException ,</span></span><br><span class="line"><span class="function">  IllegalAccessException</span>&#123;</span><br><span class="line">        T instance = tClass.newInstance();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="泛型面试题"><a href="/2019/10/20/Java/#泛型面试题" class="headerlink" title="泛型面试题:"></a>泛型面试题:</h3><ol>
<li><p>Java中的泛型是什么 ? 使用泛型的好处是什么?</p>
<p>那些拥有Java1.4或更早版本的开发背景的人都知道，在集合中存储对象并在使用前进行类型转换是多么的不方便。泛型防止了那种情况的发生。它提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException。</p>
</li>
<li><p>Java的泛型是如何工作的 ? 什么是类型擦除 ?</p>
<p>泛型是通过类型擦除来实现的，<strong>编译器在编译时擦除了所有类型相关的信息</strong>，所以<strong>在运行时不存在任何类型相关的信息</strong>。例如List<String>在运行时仅用一个List来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为<strong>编译器已经把泛型类型转换成了原始类型</strong>。根据你对这个泛型问题的回答情况，你会得到一些后续提问，比如为什么泛型是由类型擦除来实现的或者给你展示一些会导致编译器出错的错误泛型代码。请阅读我的Java中泛型是如何工作的来了解更多信息。</String></p>
</li>
<li><p>Array中可以用泛型吗?  </p>
<p>不可以, Array事实上并不支持泛型, 建议用List来代替Array,list可以提供编译期间的类型安全保证</p>
</li>
<li><p>可以把List<String>传递给一个接受List<Object>参数的方法吗？ </Object></String></p>
<p>不可以, 会导致编译错误, 因为List<Object> 可以存储任何类型的对象,而List<String> 只能是String</String></Object></p>
</li>
<li><p>编写一个泛型方法，让它能接受泛型参数并返回泛型类型? </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> cache.put(key, value);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="注解"><a href="/2019/10/20/Java/#注解" class="headerlink" title="注解"></a>注解</h2><blockquote>
<p> 注解本质是一个继承了Annotation 的特殊接口，其具体实现类是Java 运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java 运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler 的invoke 方法。该方法会从memberValues 这个Map 中索引出对应的值。而memberValues 的来源是Java 常量池。 (存了类结构文件的值)</p>
</blockquote>
<p> 自定义注解类编写的一些规则:<br> \1. Annotation 型定义为@interface, 所有的Annotation 会自动继承java.lang.Annotation这一接口,并且不能再去继承别的类或是接口.<br> \2. 参数成员只能用public 或默认(default) 这两个访问权修饰<br> \3. 参数成员只能用基本类型byte、short、char、int、long、float、double、boolean八种基本数据类型和String、Enum、Class、annotations等数据类型，以及这一些类型的数组.<br> \4. 要获取类方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation 对象，因为你除此之外没有别的获取注解对象的方法<br> \5. 注解也可以没有定义成员,，不过这样注解就没啥用了<br>PS:自定义注解需要使用到元注解 </p>
<h2 id="基本容器"><a href="/2019/10/20/Java/#基本容器" class="headerlink" title="基本容器"></a>基本容器</h2><p>List, Set, Queue 都继承自Collection接口</p>
<p><strong>List</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
<th>保存元素的顺序</th>
<th>应用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ArrayList</strong></td>
<td>随机访问速度快，内部使用数组实现。</td>
<td>迭代，插入和删除元素慢，尤其是当List]尺寸比较大的时候。</td>
<td>插入顺序</td>
<td>可变长数组</td>
</tr>
<tr>
<td><strong>LinkedList</strong></td>
<td>迭代(顺序访问经过优化)，插入，删除都很快内部使用双向链表实现</td>
<td>随机访问速度慢</td>
<td>插入顺序</td>
<td>顺序访问, 批量插入删除元素的场合</td>
</tr>
</tbody></table>
<p><strong>Set</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>保存元素的顺序</th>
<th>要求</th>
</tr>
</thead>
<tbody><tr>
<td><strong>HashSet</strong></td>
<td>为快速查找设计</td>
<td>散列存储</td>
<td>必须定义hashCode()方法</td>
</tr>
<tr>
<td>LinkedHashSet</td>
<td>和HashSet一样的查询速度，但是插入要比HashSet慢一些，因为它通过维护链表形式维护元素。</td>
<td>使用链表维护元素顺序(插入顺序)</td>
<td>必须定义hashCode()方法</td>
</tr>
<tr>
<td><strong>TreeSet</strong></td>
<td>保存有序的Set，底层通过TreeMap来实现的</td>
<td>按照排序顺序维护元素</td>
<td>必须实现Comparable接口(包含compareTo方法)</td>
</tr>
</tbody></table>
<p>HashMap, HashTable都继承自Map接口</p>
<p><strong>Queue</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>特点</th>
<th>保存元素的顺序</th>
</tr>
</thead>
<tbody><tr>
<td><strong>LinkedList</strong></td>
<td>LinkedList除了普通List之外，还添加了很多实现&lt;队列，栈，双向队列&gt;三种数据结构的方法。尤其是模拟Queue的时候在两端插入删除元素很快(经过了优化)。</td>
<td>插入的顺序</td>
</tr>
<tr>
<td>PriorityQueue</td>
<td>按照<strong>排序顺序取出元素</strong>，所以要求必须实现Comparable接口。</td>
<td>排序顺序</td>
</tr>
</tbody></table>
<p><strong>Map</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>特点</th>
<th>保存元素的顺序</th>
<th>要求</th>
</tr>
</thead>
<tbody><tr>
<td><strong>HashMap</strong></td>
<td>Map基于散列存储，插入和查询“键值对”的开销是固定的。</td>
<td>散列存储</td>
<td>存入的键需要具备hashCode()方法，当然，返回的标识不一定要唯一</td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td>为了提高速度散列了所有元素，插入查询只比HashMap慢一点点，因为它在维护散列数据结构的同时还要维护链表(插入顺序)。 但是迭代访问的时候更快，因为内部使用链表维护次序。</td>
<td>插入顺序</td>
<td>同样需要键实现hashCode()方法</td>
</tr>
<tr>
<td><strong>TreeMap</strong></td>
<td>Map基于红黑树的实现。所以所得的结果是经过排序的。</td>
<td>红黑树</td>
<td>为了排序，必须实现Comparable接口。</td>
</tr>
</tbody></table>
<h2 id="特性"><a href="/2019/10/20/Java/#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="Java-各版本的新特性"><a href="/2019/10/20/Java/#Java-各版本的新特性" class="headerlink" title="Java 各版本的新特性"></a>Java 各版本的新特性</h3><p><strong>New highlights in Java SE 8</strong></p>
<ol>
<li>Lambda Expressions</li>
<li>Pipelines and Streams</li>
<li>Date and Time API</li>
<li>Default Methods</li>
<li>Type Annotations</li>
<li>Nashhorn JavaScript Engine</li>
<li>Concurrent Accumulators</li>
<li>Parallel operations</li>
<li>PermGen Error Removed</li>
</ol>
<p><strong>New highlights in Java SE 7</strong></p>
<ol>
<li>Strings in Switch Statement</li>
<li>Type Inference for Generic Instance Creation</li>
<li>Multiple Exception Handling</li>
<li>Support for Dynamic Languages</li>
<li>Try with Resources</li>
<li>Java nio Package</li>
<li>Binary Literals, Underscore in literals</li>
<li>Diamond Syntax</li>
</ol>
<ul>
<li><a href="http://www.selfgrowth.com/articles/difference-between-java-18-and-java-17">Difference between Java 1.8 and Java 1.7?</a></li>
<li><a href="http://www.importnew.com/19345.html">Java 8 特性</a></li>
</ul>
<h3 id="Java-与-C-的区别"><a href="/2019/10/20/Java/#Java-与-C-的区别" class="headerlink" title="Java 与 C++ 的区别"></a>Java 与 C++ 的区别</h3><ul>
<li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</li>
<li>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。</li>
<li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li>
<li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li>
<li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li>
<li>Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。</li>
<li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li>
</ul>
<h3 id="JRE-or-JDK"><a href="/2019/10/20/Java/#JRE-or-JDK" class="headerlink" title="JRE or JDK"></a>JRE or JDK</h3><ul>
<li>JRE is the JVM program, Java application need to run on JRE.</li>
<li>JDK is a superset of JRE, JRE + tools for developing java programs. e.g, it provides the compiler “javac”</li>
</ul>
<h1 id="Java高级"><a href="/2019/10/20/Java/#Java高级" class="headerlink" title="Java高级"></a>Java高级</h1><h2 id="队列"><a href="/2019/10/20/Java/#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="等待队列（Condition-Queue）"><a href="/2019/10/20/Java/#等待队列（Condition-Queue）" class="headerlink" title="等待队列（Condition Queue）"></a>等待队列（Condition Queue）</h3><p> 我们都熟悉wait/notify，它主要是实现线程间协作的，其常用的使用模式如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(T t)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> <span class="keyword">while</span> (isFull())&#123;</span><br><span class="line">  wait();</span><br><span class="line"> &#125;</span><br><span class="line">  produce(t);</span><br><span class="line">  notifyAll();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (isEmpty())&#123;</span><br><span class="line"> wait();</span><br><span class="line">&#125;</span><br><span class="line">T t = consume();</span><br><span class="line">notifyAll();</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当条件满足，原来等待的线程就会立即被唤醒，这就要涉及到等待队列</strong>，等待队列中的是等待某类条件发生的线程。每一个对象都可以作为锁对象，也同时被当作一个等待队列，并具有wait，notify，notifyall方法，另见图：</p>
<img src="/2019/10/20/Java//s3mwug4mwy.png" alt="img" style="zoom:67%;">

<p>判断条件总是涉及到一些状态，如集合是否已满，是否为空等等，这些状态变量必须被锁监控，因为线程在等待或者唤醒另一个线程前，需要访问、操作这些与条件相关的状态变量，而加锁可以保证状态的一致性。另外，正如上例所示，<strong>wait方法必须包含在while循环中</strong>，原因有二：</p>
<p>  1、从线程被唤醒到重新获得锁的间隙，其他线程获取了锁并且改变了状态，使得条件重新变为false。</p>
<p>  2、如果<strong>多种条件与一个等待队列关联，必须使用notifyAll</strong>,一个线程可能在条件不满足的情况下被唤醒，这时候需要重新检查条件。</p>
<p>对象的内置锁只有一个内置等待队列与其关联，这样多个唤醒条件不同的线程就必须在同一个等待队列上，唤醒线程时必须使用notifyAll，导致大部分不符合条件的线程将被唤醒并且参与锁竞争，上下文切换频繁，性能下降，当然，notifyAll是一种比较安全保险的做法。上次我们提过还有另一种实现锁的形式，即Lock，与其对应的是Condition，它可以根据不同的条件提供对应的condition，可将上述使用模式改装一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">protected final Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> private final Condition notFull = lock.newCondition();</span><br><span class="line"> private final Condition notEmpty = lock.newCondition();</span><br><span class="line"> public <span class="keyword">void</span> produce(T t) throws InterruptedException &#123;</span><br><span class="line"> lock.lock();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="keyword">while</span> (isFull()) &#123;</span><br><span class="line"> notFull.await();</span><br><span class="line">   &#125;</span><br><span class="line">   produce(t);</span><br><span class="line"> notEmpty.signal();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> public T consume() throws InterruptedException &#123;</span><br><span class="line"> lock.lock();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="keyword">while</span> (isEmpty()) &#123;</span><br><span class="line"> notEmpty.await();</span><br><span class="line">   &#125;</span><br><span class="line">   T t = consume();</span><br><span class="line"> notFull.signal();</span><br><span class="line"> <span class="keyword">return</span> t;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>通过wait/notify实现线程间协作，是需要一定的技巧的，初级的开发人员不一定能正确使用，我们可以使用一些并发工具类，像LinkedBlockingQueue，ConcurrentHashMap，CountDownLatch实现相应的功能</p>
<h3 id="BlockingQueue"><a href="/2019/10/20/Java/#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><blockquote>
<p>   在新增的Concurrent包中，BlockingQueue很好的解决了多线程中，如何高效安全“传输”数据的问题 </p>
</blockquote>
<p>​                                                                         <img src="/2019/10/20/Java//ygyjw29x7r.jpeg" alt="img"> </p>
<p>常用的队列主要有以下两种：（当然通过不同的实现方式，还可以延伸出很多不同类型的队列，DelayQueue就是其中的一种） 　</p>
<ul>
<li><p>先进先出（FIFO）：先插入的队列的元素也最先出队列，类似于排队的功能。从某种程度上来说这种队列也体现了一种公平性。 　</p>
</li>
<li><p>后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发生的事件。 </p>
<p>​                                                                             <img src="/2019/10/20/Java//saznmdd4f0.jpeg" alt="img">  </p>
</li>
</ul>
<p><em>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。</em> </p>
<p><img src="/2019/10/20/Java//g0ajbnsdtp-1571457972709.jpeg" alt="img"></p>
<p><em>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒。</em><br>BlockingQueue的核心方法:</p>
<ul>
<li>offer(anObject):表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回false.（本方法不阻塞当前执行方法的线程） 　</li>
<li>put(anObject):把anObject加到BlockingQueue里,如果BlockQueue没有空间,则<strong>调用此方法的线程被阻断</strong>,直到BlockingQueue里面有空间再继续. 获取数据</li>
<li>poll(long timeout, TimeUnit unit)：从BlockingQueue取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。 　</li>
<li>take():取走BlockingQueue里排在首位的对象,若BlockingQueue为空,<strong>阻断进入等待状态</strong>直到BlockingQueue有新的数据被加入;  </li>
</ul>
<h3 id="常见BlockingQueue"><a href="/2019/10/20/Java/#常见BlockingQueue" class="headerlink" title="常见BlockingQueue"></a>常见BlockingQueue</h3><p><img src="/2019/10/20/Java//evyyu8oakr.jpeg" alt="img"></p>
<ul>
<li><p><strong>1. ArrayBlockingQueue</strong>      基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。 　ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是<strong>共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue</strong>；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。 </p>
</li>
<li><p><strong>2. LinkedBlockingQueue</strong>      基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当<strong>队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列</strong>，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。 作为开发者，我们需要注意的是，如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，<strong>LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了</strong>。 ArrayBlockingQueue和LinkedBlockingQueue是两个最普通也是最常用的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个类足以。</p>
</li>
<li><p><strong>3. DelayQueue</strong>      DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。 使用场景： 　DelayQueue使用场景较少，但都相当巧妙，常见的例子比如使用一个DelayQueue来管理一个超时未响应的连接队列。 </p>
</li>
<li><p><strong>4. PriorityBlockingQueue</strong>      基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。 </p>
</li>
<li><p><strong>5. SynchronousQueue</strong>      一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用<strong>中间经销商的模式会吞吐量高一些（可以批量买卖）</strong>；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。 　声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。公平模式和非公平模式的区别: 　如果采用公平模式：<strong>SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；</strong> 　但<strong>如果是非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者</strong>，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</p>
</li>
</ul>
<h2 id="缓存"><a href="/2019/10/20/Java/#缓存" class="headerlink" title="缓存"></a>缓存</h2><blockquote>
<p>缓存是现在系统中必不可少的模块，并且已经成为了高并发高性能架构的一个关键组件</p>
<p>缓存是通过牺牲强一致性来提高性能的。所以使用缓存提升性能，就是会有数据更新的延迟。这需要我们在设计时结合业务仔细思考是否适合用缓存。然后<strong>缓存一定要设置过期时间，这个时间太短太长都不好</strong>，太短的话请求可能会比较多的落到数据库上，这也意味着失去了缓存的优势。太长的话缓存中的脏数据会使系统长时间处于一个延迟的状态，而且系统中长时间没有人访问的数据一直存在内存中不过期，浪费内存。</p>
</blockquote>
<h3 id="缓存能解决的问题"><a href="/2019/10/20/Java/#缓存能解决的问题" class="headerlink" title="缓存能解决的问题"></a>缓存能解决的问题</h3><ul>
<li><p>提升性能</p>
<p>绝大多数情况下，<strong>select 是出现性能问题最大的地方</strong>。</p>
<ul>
<li>一方面，select 会有很多像 join、group、order、like 等这样丰富的语义，而这些语义是非常耗性能的；</li>
<li>另一方面，大多 数应用都是读多写少，所以加剧了慢查询的问题。</li>
</ul>
<p>分布式系统中<strong>远程调用也会耗很多性能</strong>，因为<strong>有网络开销</strong>，会导致整体的响应时间下降。为了挽救这样的性能开销，在业务允许的情况（不需要太实时的数据）下，使用缓存是非常必要的事情。</p>
</li>
<li><h6 id="缓解数据库压力"><a href="/2019/10/20/Java/#缓解数据库压力" class="headerlink" title="缓解数据库压力"></a>缓解数据库压力</h6><p>当用户请求增多时，数据库的压力将大大增加，通过缓存能够大大降低数据库的压力。</p>
</li>
</ul>
<h3 id="缓存的适用场景"><a href="/2019/10/20/Java/#缓存的适用场景" class="headerlink" title="缓存的适用场景"></a>缓存的适用场景</h3><ul>
<li><p>对于数据<strong>实时性要求不高</strong></p>
<p>对于一些<strong>经常访问但是很少改变的数据</strong>，读明显多于写，适用缓存就很有必要。比如一些网站配置项。</p>
</li>
<li><p>对于性能要求高</p>
<p>比如一些秒杀活动场景。</p>
</li>
</ul>
<h3 id="缓存三种模式"><a href="/2019/10/20/Java/#缓存三种模式" class="headerlink" title="缓存三种模式"></a>缓存三种模式</h3><p>一般来说，缓存有以下三种模式： 这三种模式各有优劣，可以根据业务场景选择使用。</p>
<ul>
<li><p>Cache Aside 更新模式</p>
<p>同时更新缓存和数据库（Cache Aside 更新模式）</p>
</li>
<li><p>Read/Write Through 更新模式</p>
<p>先更新缓存，<strong>缓存负责同步更新数据库</strong>（Read/Write Through 更新模式）</p>
</li>
<li><p>Write Behind Caching 更新模式</p>
<p>先更新缓存，缓存<strong>定时异步</strong>更新数据库（Write Behind Caching 更新模式）优点是<strong>直接操作内存速度快</strong>，多次操作可以<strong>合并持久化到数据库</strong>。缺点是<strong>数据可能会丢失</strong>，例如<strong>系统断电</strong>等。</p>
</li>
</ul>
<h4 id="Cache-Aside-更新模式"><a href="/2019/10/20/Java/#Cache-Aside-更新模式" class="headerlink" title="Cache Aside 更新模式"></a>Cache Aside 更新模式</h4><p>这是最常用的缓存模式了，具体的流程是：</p>
<ul>
<li><p><strong>失效</strong>：应用程序先从 cache 取数据，没有得到，则==<strong>从数据库中取数据，成功后，放到缓存中</strong>==。</p>
</li>
<li><p><strong>命中</strong>：应用程序从 cache 中取数据，取到后返回。</p>
</li>
<li><p><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存<strong>失效</strong>。</p>
<p>==为了防止高迸发, 导致数据不一致, 所以直接写入到库中==</p>
</li>
</ul>
<img src="/2019/10/20/Java//8AjC2hDbKk.png" alt="mark" style="zoom:80%;">

<p>注意我们上面所提到的，缓存更新时先更新数据库，然后在让缓存失效。那么为什么不是直接更新缓存呢？这里有一些缓存更新的坑，我们需要避免入坑。</p>
<ul>
<li><h5 id="避坑指南一"><a href="/2019/10/20/Java/#避坑指南一" class="headerlink" title="避坑指南一"></a>避坑指南一</h5><p><strong>先更新数据库，再更新缓存。</strong>这种做法最大的问题就是<strong>两个并发的写操作导致脏数据</strong>。如下图（以Redis和Mysql为例），两个并发更新操作，数据库先更新的反而后更新缓存，数据库后更新的反而先更新缓存。这样就会造成数据库和缓存中的数据不一致，应用程序中读取的都是脏数据。</p>
<img src="/2019/10/20/Java//b8EAiJHeAL.png" alt="mark" style="zoom:67%;">
</li>
<li><h4 id="避坑指南二"><a href="/2019/10/20/Java/#避坑指南二" class="headerlink" title="避坑指南二"></a>避坑指南二</h4><p><strong>先删除缓存，再更新数据库。</strong>这个逻辑是错误的，因为<strong>两个并发的读和写操作导致脏数据</strong>。如下图（以Redis和Mysql为例）。假设更新操作先删除了缓存，此时正好有一个并发的读操作，没有命中缓存后从数据库中取出老数据并且更新回缓存，这个时候更新操作也完成了数据库更新。此时，数据库和缓存中的数据不一致，应用程序中读取的都是原来的数据（脏数据）。</p>
<img src="/2019/10/20/Java//e3A7c3L176.png" alt="mark" style="zoom:67%;">
</li>
<li><h4 id="避坑指南三"><a href="/2019/10/20/Java/#避坑指南三" class="headerlink" title="避坑指南三"></a>避坑指南三</h4><p><strong>先更新数据库，再删除缓存。</strong>这种做法其实不能算是坑，在实际的系统中也推荐使用这种方式。但是这种方式理论上还是可能存在问题。如下图（以Redis和Mysql为例），查询操作没有命中缓存，然后查询出数据库的老数据。此时有一个并发的更新操作，更新操作在读操作之后更新了数据库中的数据并且删除了缓存中的数据。然而读操作将从数据库中读取出的老数据更新回了缓存。这样就会造成数据库和缓存中的数据不一致，应用程序中读取的都是原来的数据（脏数据）。</p>
</li>
</ul>
<img src="/2019/10/20/Java//06kCb330cg.png" alt="mark" style="zoom:67%;">

<p>但是，仔细想一想，这种并发的概率极低。因为这个条件需要发生在读缓存时缓存失效，而且有一个并发的写操作。实际上数据库的<strong>写操作会比读操作慢得多</strong>，而且<strong>还要加锁</strong>，而<strong>读操作必需在写操作前进入数据库操作</strong>，又要晚于写操作更新缓存，所有这些条件都具备的概率并不大。但是为了避免这种极端情况造成脏数据所产生的影响，我们还是要<strong>为缓存设置过期时间</strong>。</p>
<h4 id="Read-Write-Through-更新模式"><a href="/2019/10/20/Java/#Read-Write-Through-更新模式" class="headerlink" title="Read/Write Through 更新模式"></a>Read/Write Through 更新模式</h4><p>在上面的 <strong>Cache Aside 更新模式中，应用代码需要维护两个数据存储</strong>，一个是缓存（Cache），一个是数据库（Repository）。而在Read/Write Through 更新模式中，应用程序只需要维护缓存，数据库的维护工作由缓存代理了。</p>
<img src="/2019/10/20/Java//FC3blLI8Da.png" alt="mark" style="zoom:67%;">

<ul>
<li><h5 id="Read-Through"><a href="/2019/10/20/Java/#Read-Through" class="headerlink" title="Read Through"></a>Read Through</h5><p>Read Through 模式就是在查询操作中更新缓存，也就是说，当缓存失效的时候，Cache Aside 模式是由调用方负责把数据加载入缓存，而 Read Through 则用缓存服务自己来加载。</p>
</li>
<li><h5 id="Write-Through"><a href="/2019/10/20/Java/#Write-Through" class="headerlink" title="Write Through"></a>Write Through</h5><p>Write Through 模式和 Read Through 相仿，不过是在更新数据时发生。当有数据更新的时候，如果<strong>没有命中缓存，直接更新数据库</strong>，然后返回。如果<strong>命中了缓存，则更新缓存</strong>，然后由<strong>缓存自己更新数据库</strong>（这是一个同步操作）。</p>
</li>
</ul>
<h4 id="Write-Behind-Caching-更新模式"><a href="/2019/10/20/Java/#Write-Behind-Caching-更新模式" class="headerlink" title="Write Behind Caching 更新模式"></a>Write Behind Caching 更新模式</h4><p>Write Behind Caching 更新模式就是在<strong>更新数据的时候，只更新缓存，不更新数据库</strong>，而我们的缓存会异步地批量更新数据库。这个设计的<strong>好处就是直接操作内存速度快</strong>。因为异步，Write Behind Caching 更新模式还可以合并对同一个数据的多次操作到数据库，所以性能的提高是相当可观的。</p>
<p>但==其带来的问题是，<strong>数据不是强一致性的，而且可能会丢失</strong>==。另外，Write Behind Caching 更新模式实现逻辑比较复杂，因为它需要确认有哪些数据是被更新了的，哪些数据需要刷到持久层上。只有在缓存需要失效的时候，才会把它真正持久起来。</p>
<img src="/2019/10/20/Java//fhHjieAaGb.png" alt="mark" style="zoom: 67%;">

<h3 id="缓存失效策略"><a href="/2019/10/20/Java/#缓存失效策略" class="headerlink" title="缓存失效策略"></a>缓存失效策略</h3><blockquote>
<p>一般而言，缓存系统中都会对缓存的对象设置一个超时时间，避免浪费相对比较稀缺的缓存资源。对于缓存时间的处理有两种，分别是主动失效和被动失效。</p>
</blockquote>
<ul>
<li>主动失效<br>主动失效是指<strong>系统有一个主动检查缓存是否失效的机制</strong>，比如通过定时任务或者单独的线程不断的去检查缓存队列中的对象是否失效，如果失效就把他们清除掉，避免浪费。主动失效的好处是能够避免内存的浪费，<strong>但是会占用额外的CPU时间</strong>。</li>
<li>被动失效<br>被动失效是<strong>通过访问缓存对象的时候才去检查缓存对象是否失效</strong>，这样的好处是系统占用的CPU时间更少，但是风险是<strong>长期不被访问的</strong>缓存对象<strong>不会被系统清除</strong>。</li>
</ul>
<h3 id="缓存淘汰策略"><a href="/2019/10/20/Java/#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h3><blockquote>
<p>缓存淘汰，又称为缓存逐出(cache replacement algorithms或者cache replacement policies)，是指在存储空间不足的情况下，缓存系统主动释放一些缓存对象获取更多的存储空间。一般<strong>LRU</strong>用的比较多，可以重点了解一下。</p>
</blockquote>
<ul>
<li>FIFO<br>先进先出（First In First Out）是一种简单的淘汰策略，缓存对象以队列的形式存在，如果空间不足，就释放队列头部的（先缓存）对象。一般<strong>用链表实现。</strong></li>
<li><strong>LRU</strong><br><strong>最近最久未使用</strong>（Least Recently Used），这种策略是根据访问的时间先后来进行淘汰的，如果空间不足，会释放最久没有访问的对象（上次访问时间最早的对象）。比较常见的是<strong>通过优先队列来实现。</strong></li>
<li>LFU<br>最近最少使用（Least Frequently Used），这种策略根据最近访问的频率来进行淘汰，如果空间不足，会释放最近访问频率最低的对象。这个算法也是<strong>用优先队列实现</strong>的比较常见。7</li>
</ul>
<h3 id="分布式缓存的常见问题"><a href="/2019/10/20/Java/#分布式缓存的常见问题" class="headerlink" title="分布式缓存的常见问题"></a>分布式缓存的常见问题</h3><h4 id="缓存穿透"><a href="/2019/10/20/Java/#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><ul>
<li>DB中不存在数据，<strong>==每次都穿过缓存查DB==</strong>，造成DB的压力。一般是网络攻击</li>
<li>解决方案：放入一个特殊对象（比如特定的无效对象，当然比较好的方式是使用包装对象）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们先看看最简单的青铜姿势</span></span><br><span class="line">value = cache.get(key)</span><br><span class="line"><span class="keyword">if</span> value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    value = db.get(key)</span><br><span class="line">    <span class="comment"># 由于value为空，实际上缓存并没有写进去，一旦这个key成为热点，db的压力将会极大</span></span><br><span class="line">    cache.put(key, value, expire)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单优化一下，升级成为白银姿势</span></span><br><span class="line">wrapped_value = cache.get(key)</span><br><span class="line"><span class="keyword">if</span> wrapped_value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    value = db.get(key)</span><br><span class="line">    <span class="comment"># 即使是空对象也通过包装对象放到缓存，当然考虑到空间还可以采用特殊值（比如-1代表不存在）的方式</span></span><br><span class="line">    cache.put(key, wrapped_value(value), expire)</span><br><span class="line">    <span class="keyword">return</span> wrapped_value.value</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> wrapped_value.value</span><br></pre></td></tr></table></figure>

<h4 id="缓存击穿"><a href="/2019/10/20/Java/#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><ul>
<li><p>在缓存失效的瞬间大量请求，造成DB的压力瞬间增大</p>
</li>
<li><p>解决方案：<strong>更新缓存时使用分布式锁锁住服务</strong>，防止请求穿透直达DB</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 白银姿势</span></span><br><span class="line">wrapped_value = cache.get(key)</span><br><span class="line"><span class="keyword">if</span> wrapped_value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    value = db.get(key)</span><br><span class="line">    <span class="comment"># 在写入缓存之前，大量的请求突然涌入，db瞬间被打垮</span></span><br><span class="line">    cache.put(key, wrapped_value(value), expire)</span><br><span class="line">    <span class="keyword">return</span> wrapped_value.value</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> wrapped_value.value</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 在白银姿势的基础上我们再优化成黄金姿势</span></span><br><span class="line">wrapped_value = cache.get(key)</span><br><span class="line"><span class="keyword">if</span> wrapped_value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># 查db之前加一把锁</span></span><br><span class="line">    <span class="keyword">while</span> wrapped_value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> try_lock(key):</span><br><span class="line">            value = db.get(key)</span><br><span class="line">            cache.put(key, wrapped_value(value), expire)</span><br><span class="line">            <span class="keyword">return</span> wrapped_value.value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 等待10毫秒之后重试</span></span><br><span class="line">            sleep(<span class="number">0.01</span>)</span><br><span class="line">            wrapped_value = cache.get(key)</span><br><span class="line">    <span class="keyword">return</span> wrapped_value.value</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> wrapped_value.value</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="缓存雪崩"><a href="/2019/10/20/Java/#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><ul>
<li><p>大量<strong>缓存设置了相同的失效时间</strong>，同一时间失效，造成服务瞬间性能急剧下降</p>
</li>
<li><p>解决方案：缓存时间使用<strong>基本时间加上随机时间</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过随机失效时间登上王者姿势</span></span><br><span class="line">wrapped_value = cache.get(key)</span><br><span class="line"><span class="keyword">if</span> wrapped_value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># 查db之前加一把锁</span></span><br><span class="line">    <span class="keyword">while</span> wrapped_value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> try_lock(key):</span><br><span class="line">            value = db.get(key)</span><br><span class="line">            <span class="comment"># 嗯，就是一个随机失效时间，最好是在某个区间</span></span><br><span class="line">            cache.put(key, wrapped_value(value), random_expire())</span><br><span class="line">            <span class="keyword">return</span> wrapped_value.value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 等待10毫秒之后重试</span></span><br><span class="line">            sleep(<span class="number">0.01</span>)</span><br><span class="line">            wrapped_value = cache.get(key)</span><br><span class="line">    <span class="keyword">return</span> wrapped_value.value</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> wrapped_value.value</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="设计模式"><a href="/2019/10/20/Java/#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><blockquote>
<p>常见:  <strong>单例模式、工厂模式、建造模式、观察者模式、适配器模式、代理模式、装饰模式.</strong></p>
</blockquote>
<h3 id="设计模式的六大原则及其含义"><a href="/2019/10/20/Java/#设计模式的六大原则及其含义" class="headerlink" title="设计模式的六大原则及其含义:"></a>设计模式的六大原则及其含义:</h3><ol>
<li>单一职责原则：<strong>一个类只负责一个功能领域中的相应职责</strong>，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。主要作用实现代码高内聚，低耦合。</li>
<li>开闭原则：一个软件实体应当<strong>对扩展开放，对修改关闭</strong>。即软件实体应尽量在不修改原有代码的情况下进行扩展。</li>
<li>里氏替换原则：所有引用基类（父类）的地方必须能透明地使用其子类的对象。里氏替换原则是实现开闭原则的方式之一</li>
<li>依赖倒置原则：抽象不应该依赖于细节，<strong>细节应当依赖于抽象</strong>。换言之，要针对接口编程，而不是针对实现编程。</li>
<li>接口隔离原则：<strong>使用多个专门的接口，而不使用单一的总接口</strong>，即客户端不应该依赖那些它不需要的接口。</li>
<li>迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用。</li>
</ol>
<h3 id="常见模式及优缺点："><a href="/2019/10/20/Java/#常见模式及优缺点：" class="headerlink" title="常见模式及优缺点："></a><strong>常见模式及优缺点</strong>：</h3><ul>
<li><p>饿汉式：</p>
<p>优点：不用加锁可以确保对象的唯一性，线程安全。</p>
<p>缺点：初始化对象会浪费不必要的资源，未实现延迟加载。</p>
</li>
<li><p>懒汉式：</p>
<p>优点：实现了延时加载。</p>
<p>缺点：线程不安全，想实现线程安全，得加锁（synchronized），这样会浪费一些不必要的资源。</p>
</li>
<li><p>双重检测锁式（</p>
<p>Double Check Lock –DCL）：</p>
<p>优点：资源利用率高，效率高。</p>
<p>缺点：第一次加载稍慢，由于java处理器允许乱序执行，偶尔会失败。</p>
</li>
<li><p>静态内部式：</p>
<p>优点：第一次调用方法时才加载类，不仅保证线程安全还能保证对象的唯一，还延迟了单例的实例化</p>
<p>缺点：无确定</p>
</li>
<li><p>枚举实现单例模式</p>
<p>优点: 线程安全, 任何模式下都是单例的, 包括序列化</p>
<p>推荐使用<strong>静态内部式</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>)  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *当第一次加载Singleton类时并不会初始化SINGLRTON,只有第一次调用getInstance方法的时候才会初始化SINGLETON</span></span><br><span class="line"><span class="comment">    *第一次调用getInstance 方法的时候虚拟机才会加载SingletonHoder类,这种方式不仅能够保证线程安全,也能够保证对象的唯一,</span></span><br><span class="line"><span class="comment">    *还延迟了单例的实例化,所有推荐使用这种方式</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton4 SINGLETON = <span class="keyword">new</span> Singleton4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设计模式在实际场景的应用"><a href="/2019/10/20/Java/#设计模式在实际场景的应用" class="headerlink" title="设计模式在实际场景的应用"></a>设计模式在实际场景的应用</h3><p>单例：连接数据库，记录日志</p>
<h3 id="Spring中用到了哪些设计模式"><a href="/2019/10/20/Java/#Spring中用到了哪些设计模式" class="headerlink" title="==Spring中用到了哪些设计模式=="></a>==Spring中用到了哪些设计模式==</h3><ol>
<li>工厂模式：spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。</li>
<li>代理模式：Spring的AOP就是代理模式的体现。</li>
<li>观察者模式：常用的地方是Listener的实现，spring中ApplicationListener就是观察者的体现。</li>
<li>策略模式：spring在实例化对象的时候使用到了。</li>
<li>工厂方法：Spring中的FactoryBean就是典型的工厂方法模式。</li>
<li>单例模式: </li>
</ol>
<p>参考：<a href="https://www.cnblogs.com/hwaggLee/p/4510687.html">https://www.cnblogs.com/hwaggLee/p/4510687.html</a></p>
<h3 id="MyBatis中用到了哪些设计模式"><a href="/2019/10/20/Java/#MyBatis中用到了哪些设计模式" class="headerlink" title="==MyBatis中用到了哪些设计模式=="></a>==MyBatis中用到了哪些设计模式==</h3><ol>
<li>Builder模式，例如SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder；</li>
<li>工厂模式，例如SqlSessionFactory、ObjectFactory、MapperProxyFactory；</li>
<li>单例模式，例如ErrorContext和LogFactory；</li>
<li>代理模式，Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果；</li>
<li>组合模式，例如SqlNode和各个子类ChooseSqlNode等；</li>
<li>模板方法模式，例如BaseExecutor和SimpleExecutor，还有BaseTypeHandler和所有的子类例如IntegerTypeHandler；</li>
<li>适配器模式，例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现；</li>
<li>装饰者模式，例如Cache包中的cache.decorators子包中等各个装饰者的实现；</li>
<li>迭代器模式，例如迭代器模式PropertyTokenizer；</li>
</ol>
<p>参考：<a href="https://www.cnblogs.com/shuchen007/p/9193179.html">https://www.cnblogs.com/shuchen007/p/9193179.html</a></p>
<h3 id="代理模式-Proxy"><a href="/2019/10/20/Java/#代理模式-Proxy" class="headerlink" title="代理模式(Proxy)"></a>代理模式(Proxy)</h3><p><strong>静态代理:</strong> AspectJ</p>
<p><strong>动态代理:</strong></p>
<ul>
<li>cglib(静态)</li>
<li>jdk(动态)</li>
</ul>
<h2 id="类加载器"><a href="/2019/10/20/Java/#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><blockquote>
<p>顾名思义，类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。</p>
<p>有三类类加载器:</p>
<ul>
<li>启动类加载器 BootStrap ClassLoader</li>
<li>扩展类加载器 Extension ClassLoader</li>
<li>应用类加载器 Application ClassLoader</li>
</ul>
</blockquote>
<img src="/2019/10/20/Java//2095550-c1889cec927a36d0.webp" alt="img" style="zoom:67%;">

<h4 id="ClassLoader"><a href="/2019/10/20/Java/#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h4><p>ClassLoader类是一个抽象类，它定义了类加载器的基本方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td>getParent()</td>
<td align="center">返回该类加载器的父类加载器。</td>
</tr>
<tr>
<td>loadClass(String name)</td>
<td align="center">加载名称为 name的类，返回的结果是 java.lang.Class类的实例。</td>
</tr>
<tr>
<td>findClass(String name)</td>
<td align="center">查找名称为 name的类，返回的结果是 java.lang.Class类的实例。</td>
</tr>
<tr>
<td>findLoadedClass(String name)</td>
<td align="center">查找名称为 name的已经被加载过的类，返回的结果是 java.lang.Class类的实例。</td>
</tr>
<tr>
<td>defineClass(String name, byte[] b, int off, int len)</td>
<td align="center"><strong>把字节数组 b中的内容转换成 Java 类</strong>，返回的结果是 java.lang.Class类的实例。这个方法被声明为 final的。</td>
</tr>
</tbody></table>
<h4 id="来看看-loadClass-方法的代码：双亲委托机制"><a href="/2019/10/20/Java/#来看看-loadClass-方法的代码：双亲委托机制" class="headerlink" title="来看看 loadClass 方法的代码：双亲委托机制"></a>来看看 loadClass 方法的代码：双亲委托机制</h4><p><strong>自定义类加载器一般只重写findClass方法即可</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)&#123;</span><br><span class="line">    Class c = findLoadedClass(name);<span class="comment">//是否已经加载</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;<span class="comment">//没有加载</span></span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//使用父加载器加载此类</span></span><br><span class="line">            c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果父加载器没有成功加载，则自己尝试加载</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="IO"><a href="/2019/10/20/Java/#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="Java的io，nio，bio区别"><a href="/2019/10/20/Java/#Java的io，nio，bio区别" class="headerlink" title="Java的io，nio，bio区别"></a>Java的io，nio，bio区别</h3><blockquote>
<p><strong>Java IO</strong>（Java数据流）主要就是Java用来读取和输出数据流</p>
<p><strong>读取纯文本数据优选用字符流，其他使用字节流</strong></p>
</blockquote>
<p><strong>Java中IO主要有两类</strong></p>
<ul>
<li>|——&gt;字节流（读写以字节（8bit）为单位，InputStream和OutputStream为主要代表              </li>
<li>|——&gt;字符流（读写以字符为单位，Reader和Writer为主要代表）</li>
</ul>
<p><strong>BIO, NIO, AIO的区别</strong></p>
<ul>
<li>BIO: 同步并阻塞, 服务器模式为一个连接一个线程, 客户端有连接请求时,就必须开启一个线程进行处理, 会造成很大的线程开销–数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下</li>
<li>NIO: 同步非阻塞,服务器模式为:  一个请求一个线程, 即客户端的请求都会注册到多路复用机,轮询到有io请求时才启动一个线程进行处理.<strong>把一些无效的连接挡在了启动线程之前，减少了这部分资源的浪费</strong> –对于<strong>高负载、高并发</strong>的（网络）应用，应使用 <strong>NIO 的非阻塞模式</strong>来开发</li>
<li>AIO: 一部非阻塞, 一个有效的请求一个线程, 客户端的io请求都是os先完成了在通知服务器应用取启动线程进行处理<strong>将一些暂时可能无效的请求挡在了启动线程之前</strong></li>
</ul>
<h3 id="I-O-模型"><a href="/2019/10/20/Java/#I-O-模型" class="headerlink" title="I/O 模型"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=一、io-模型">I/O 模型</a></h3><p>一个输入操作通常包括两个阶段：</p>
<ul>
<li>等待数据准备好(<strong>数据复制到内核缓冲区</strong>)</li>
<li>从内核向进程复制数据</li>
</ul>
<p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p>
<p>Unix 有五种 I/O 模型：</p>
<ul>
<li>阻塞式 I/O (BIO)</li>
<li><strong>非阻塞式 I/O</strong> (NIO)</li>
<li>I/O 复用（select 和 poll）</li>
<li>信号驱动式 I/O（SIGIO）</li>
<li><strong>异步 I/O（AIO）</strong></li>
</ul>
<h4 id="阻塞式-I-O"><a href="/2019/10/20/Java/#阻塞式-I-O" class="headerlink" title="阻塞式 I/O"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=阻塞式-io">阻塞式 I/O</a></h4><blockquote>
<p>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。</p>
<p>应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为<strong>其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高</strong>。</p>
</blockquote>
<p>下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen);Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<img src="/2019/10/20/Java//1492928416812_4-1570685864033.png" alt="img" style="zoom: 67%;">

<h4 id="非阻塞式-I-O"><a href="/2019/10/20/Java/#非阻塞式-I-O" class="headerlink" title="非阻塞式 I/O"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=非阻塞式-io">非阻塞式 I/O</a></h4><blockquote>
<p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是<strong>需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）</strong>。</p>
<p>由于 CPU 要处理更多的系统调用，因此这种模型的 <strong>CPU 利用率比较低-因为要去不断的轮询是否数据准备好</strong>。</p>
</blockquote>
<img src="/2019/10/20/Java//1492929000361_5.png" alt="img" style="zoom:67%;">

<p>==<strong>此时数据准备阶段不会阻塞, 而数据复制阶段一样会阻塞</strong>==</p>
<h4 id="I-O-复用"><a href="/2019/10/20/Java/#I-O-复用" class="headerlink" title="I/O 复用"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=io-复用">I/O 复用</a></h4><blockquote>
<p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。</p>
<p>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。</p>
<p><strong>I/O复用可以避免频繁创建和销毁线程, 以及切换线程的开销</strong></p>
</blockquote>
<p>如果一个 Web 服务器没有 I/O 复用，那么<strong>每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小</strong>。</p>
<img src="/2019/10/20/Java//1492929444818_6.png" alt="img" style="zoom:67%;">

<p><strong>==在数据准备阶段select是阻塞的==</strong></p>
<h4 id="信号驱动-I-O"><a href="/2019/10/20/Java/#信号驱动-I-O" class="headerlink" title="信号驱动 I/O"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=信号驱动-io">信号驱动 I/O</a></h4><blockquote>
<p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p>
<p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 <strong>CPU 利用率更高</strong>-数据准备阶段不阻塞。</p>
</blockquote>
<img src="/2019/10/20/Java//1492929553651_7.png" alt="img" style="zoom:67%;">



<h4 id="异步-I-O-AIO"><a href="/2019/10/20/Java/#异步-I-O-AIO" class="headerlink" title="异步 I/O (AIO)"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=异步-io">异步 I/O</a> (AIO)</h4><blockquote>
<p>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p>
<p>异步 I/O 与信号驱动 I/O 的区别在于，<strong>异步 I/O 的信号是通知应用进程 I/O 完成</strong>，而<strong>信号驱动 I/O 的信号是通知应用进程可以开始 I/O</strong>。</p>
</blockquote>
<img src="/2019/10/20/Java//1492930243286_8.png" alt="img" style="zoom:67%;">



<h4 id="五大-I-O-模型比较"><a href="/2019/10/20/Java/#五大-I-O-模型比较" class="headerlink" title="五大 I/O 模型比较"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=五大-io-模型比较">五大 I/O 模型比较</a></h4><ul>
<li>同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。</li>
<li>异步 I/O：<strong>第二阶段应用进程不会阻塞</strong>。</li>
</ul>
<p>同步 I/O 包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O ，它们的主要区别在第一个阶段。</p>
<p>非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。</p>
<img src="/2019/10/20/Java//1492928105791_3.png" alt="img" style="zoom:67%;">



<h4 id="I-O-复用-详细讲解"><a href="/2019/10/20/Java/#I-O-复用-详细讲解" class="headerlink" title="I/O 复用 详细讲解"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=二、io-复用">I/O 复用 详细讲解</a></h4><p>select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。</p>
<h5 id="select"><a href="/2019/10/20/Java/#select" class="headerlink" title="select"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=select">select</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。</p>
<ul>
<li>fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听少于 FD_SETSIZE 数量的描述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。</li>
<li>timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。</li>
<li>成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。</li>
</ul>
<h5 id="poll"><a href="/2019/10/20/Java/#poll" class="headerlink" title="poll"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=poll">poll</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。</p>
<p>poll 中的描述符是 pollfd 类型的数组，pollfd 的定义如下：</p>
<h5 id="比较"><a href="/2019/10/20/Java/#比较" class="headerlink" title="比较"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=比较">比较</a></h5><h6 id="1-功能"><a href="/2019/10/20/Java/#1-功能" class="headerlink" title="1. 功能"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_1-功能">1. 功能</a></h6><p>select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。</p>
<ul>
<li>select 会修改描述符，而 poll 不会；</li>
<li>select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；</li>
<li>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。</li>
<li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。</li>
</ul>
<h6 id="2-速度"><a href="/2019/10/20/Java/#2-速度" class="headerlink" title="2. 速度"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_2-速度">2. 速度</a></h6><p>select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。</p>
<h6 id="3-可移植性"><a href="/2019/10/20/Java/#3-可移植性" class="headerlink" title="3. 可移植性"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_3-可移植性">3. 可移植性</a></h6><p>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</p>
<h5 id="epoll"><a href="/2019/10/20/Java/#epoll" class="headerlink" title="epoll"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=epoll">epoll</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。</p>
<p>从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。</p>
<p>epoll 仅适用于 Linux OS。</p>
<p>epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。</p>
<p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。</p>
<h6 id="工作模式"><a href="/2019/10/20/Java/#工作模式" class="headerlink" title="工作模式"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=工作模式">工作模式</a></h6><p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。</p>
<p><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_1-lt-模式">1. LT 模式</a></p>
<p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p>
<p><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_2-et-模式">2. ET 模式</a></p>
<p>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。</p>
<p>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h4 id="应用场景"><a href="/2019/10/20/Java/#应用场景" class="headerlink" title="应用场景"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=应用场景">应用场景</a></h4><p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p>
<h5 id="1-select-应用场景"><a href="/2019/10/20/Java/#1-select-应用场景" class="headerlink" title="1. select 应用场景"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_1-select-应用场景">1. select 应用场景</a></h5><p>select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。</p>
<p>select 可移植性更好，几乎被所有主流平台所支持。</p>
<h5 id="2-poll-应用场景"><a href="/2019/10/20/Java/#2-poll-应用场景" class="headerlink" title="2. poll 应用场景"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_2-poll-应用场景">2. poll 应用场景</a></h5><p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p>
<h5 id="3-epoll-应用场景"><a href="/2019/10/20/Java/#3-epoll-应用场景" class="headerlink" title="3. epoll 应用场景"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_3-epoll-应用场景">3. epoll 应用场景</a></h5><p>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。</p>
<p>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。</p>
<p>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</p>
<ul>
<li>I/O 复用（select 和 poll）</li>
<li>信号驱动式 I/O（SIGIO）</li>
<li><strong>异步 I/O（AIO）</strong></li>
</ul>
<h2 id="多线程"><a href="/2019/10/20/Java/#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="进程和线程区别"><a href="/2019/10/20/Java/#进程和线程区别" class="headerlink" title="进程和线程区别"></a>进程和线程区别</h3><ul>
<li>进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例</li>
<li>线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量,是一个独立的执行单元<strong>主要用于解决程序执行的效率</strong></li>
</ul>
<h3 id="守护线程-amp-非守护线程"><a href="/2019/10/20/Java/#守护线程-amp-非守护线程" class="headerlink" title="守护线程&amp;非守护线程"></a>守护线程&amp;非守护线程</h3><blockquote>
<p>GC线程属于守护线程, 和主线程同生共死</p>
</blockquote>
<p>用户线程也叫非守护线程, 用户自己创建的线程, 如果主线程停止掉,不会影响用户线程. 用户线程非守护线程</p>
<h3 id="线程的状态转换"><a href="/2019/10/20/Java/#线程的状态转换" class="headerlink" title="线程的状态转换"></a>线程的状态转换</h3> <img src="/2019/10/20/Java//1294022-20171206070245644-1496567738.png" alt="img" style="zoom:67%;"> 

<h3 id="线程安全"><a href="/2019/10/20/Java/#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p><strong>coout++</strong></p>
<p>count++ 这行代码实际上需要执行三个指令：</p>
<p>getfield：从内存中获取变量 count 的值<br>iadd：将 count 加 1<br>putfield：将加 1 后的结果赋值给 count 变量<br><strong>这也就是线程不安全的原因所在，因为 count++ 操作不具备原子性。</strong></p>
<p>原子性操作指的是不可被中断的一个或一系列操作。下图描述了为什么非原子操作造成了这里的线程不安全问题</p>
 <img src="/2019/10/20/Java//20190704114751129.png" alt="在这里插入图片描述" style="zoom: 50%;"> 

<p>假设有两个线程去执行 add 操作，此时 count 是 0，那么存在上图中的这种可能，在线程 A 执行这三步的过程中 cpu 时间片耗尽线程 B 被调度，此时由于内存中 count 的值仍为 0（因为线程 A 的操作结果还未刷新到内存中），所以线程 B 仍是在 0 的基础上执行自增，所以导致最终内存中的 count 是 1，而不是 2.</p>
<h3 id="为什么要用线程池"><a href="/2019/10/20/Java/#为什么要用线程池" class="headerlink" title="为什么要用线程池?"></a><strong>为什么要用线程池?</strong></h3><blockquote>
<p>线程池作用就是限制系统中执行线程的数量。根据系统的环境情况, 可以手动或者自动的设置线程数量, 避免浪费系统资源, 造成系统拥挤, 当一个新任务需要运行时，如果线程池 中有等待的工作线程，就可以开始运行了；否则进入等待队列。 </p>
</blockquote>
<ol>
<li><p><strong>减少</strong>了<strong>创建和销毁线程的次数</strong>, 每个<strong>工作线程</strong>都可以被<strong>重复利用</strong>, 可执行多个任务</p>
</li>
<li><p>可以根据系统的承受能力, <u>调整线程池中工作线程的数目, 防止因为消耗过多的内存</u>, (每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。 </p>
<p>Java里边线程池的顶级接口时Executor, 但是严格意义上将Executor并不是一个线程池, 而是一个执行工具,真正的线程池接口时<strong>ExecutorService</strong></p>
</li>
</ol>
<h4 id="线程中重要的几个类"><a href="/2019/10/20/Java/#线程中重要的几个类" class="headerlink" title="线程中重要的几个类"></a>线程中重要的几个类</h4><ul>
<li><p><strong>ExecutorService</strong> </p>
<p>真正的线程池接口。</p>
</li>
<li><p><strong>ScheduledExecutorService</strong><br>能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。</p>
</li>
<li><p><strong>ThreadPoolExecutor</strong><br>ExecutorService的默认实现。</p>
</li>
<li><p><strong>ScheduledThreadPoolExecutor</strong><br>继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。</p>
</li>
</ul>
<h4 id="new-Thread的弊端"><a href="/2019/10/20/Java/#new-Thread的弊端" class="headerlink" title="new Thread的弊端"></a>new Thread的弊端</h4><ol>
<li>每次new Thread新建对象性能差。 </li>
<li>线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。 </li>
<li>缺乏更多功能，如定时执行、定期执行、线程中断。 </li>
</ol>
<h4 id="Java提供的四种线程池的好处在于："><a href="/2019/10/20/Java/#Java提供的四种线程池的好处在于：" class="headerlink" title="Java提供的四种线程池的好处在于："></a>Java提供的四种线程池的好处在于：</h4><ol>
<li>重用存在的线程，减少对象创建、消亡的开销，性能佳。 </li>
<li>可有效<strong>控制最大并发线程数</strong>，提高系统资源的使用率，同时<strong>避免过多资源竞争</strong>，避免<strong>堵塞</strong>。 </li>
<li>提供<u>定时执行、定期执行、单线程、并发数控制</u>等功能。</li>
</ol>
<h3 id="四种线程池"><a href="/2019/10/20/Java/#四种线程池" class="headerlink" title="四种线程池"></a><strong>四种线程池</strong></h3><p>Java通过Executors提供<strong>四种线程池</strong>,分别为:</p>
<ol>
<li><p><strong>newCachedThreadPool</strong></p>
<p>创建一个可缓存的线程池, 如果线程池长度超过处理需要, 可以灵活回收空闲线程, 若无可回收,则新建线程</p>
<p>==适应场景: 创建一个可以无限扩大的线程池，适用于服务器负载较轻，执行很多短期异步任务。== </p>
</li>
<li><p><strong>newFixedThreadPool</strong></p>
<p>创建一个定长线程池,可控制线程最大并发数, 采用无界的阻塞队列，所以实际线程数量永远不会变化,超出的线程会在队列中等待</p>
<p>适应场景:适用于可以预测线程数量的业务中，或者服务器负载较重，对当前线程数量进行限制。</p>
</li>
<li><p><strong>newScheduledThreadPool</strong></p>
<p>创建一个定长线程池, 至此定时及周期性任务执行</p>
<p>==适应场景: 适用于需要多个后台线程执行周期任务的场景。==</p>
</li>
<li><p><strong>newSingleThreadExecutor</strong></p>
<p>创建一个单线程化的线程池, 它只会用唯一的工作线程来执行任务, <u>保证所有任务按照指定顺序(FIFO, LIFO,优先级)执行</u></p>
<p>==适应场景: 适用于需要保证顺序执行各个任务，并且在任意时间点，不会有多个线程是活动的场景。== </p>
</li>
</ol>
<h4 id="submit-和execute-的以及shutdown-和shutdownNow-的区别"><a href="/2019/10/20/Java/#submit-和execute-的以及shutdown-和shutdownNow-的区别" class="headerlink" title="submit()和execute()的以及shutdown()和shutdownNow()的区别"></a>submit()和execute()的以及shutdown()和shutdownNow()的区别</h4><ul>
<li>submit()，提交一个线程任务，可以<strong>接受回调函数的返回值吗</strong>，适用于需要处理返回着或者异常的业务场景 </li>
<li>execute()，执行一个任务，<strong>没有返回值</strong> </li>
<li>shutdown()，表示<strong>不再接受新任务</strong>，但<strong>不会强行终止已经提交</strong>或者<strong>正在执行</strong>中的<strong>任务</strong> </li>
<li>shutdownNow()，对于<strong>尚未执行的任务全部取消</strong>，<strong>正在执行</strong>的任务全部发出interrupt()，<strong>停止执行</strong> </li>
</ul>
<h4 id="RejectedExecutionHandler-线程池四种拒绝任务策略"><a href="/2019/10/20/Java/#RejectedExecutionHandler-线程池四种拒绝任务策略" class="headerlink" title="RejectedExecutionHandler 线程池四种拒绝任务策略"></a>RejectedExecutionHandler 线程池四种拒绝任务策略</h4><blockquote>
<p>线程池有一个任务队列，用于缓存所有待处理的任务，正在处理的任务将从任务队列中移除。因此在任务队列长度有限的情况下就会出现新任务的拒绝处理问题，需要有一种策略来处理应该加入任务队列却因为队列已满无法加入的情况。另外在线程池关闭的时候也需要对任务加入队列操作进行额外的协调处理。</p>
</blockquote>
<p><strong>RejectedExecutionHandler提供了四种方式来处理任务拒绝策略</strong>:  -&gt;==这四种策略是独立无关的==</p>
<ul>
<li>1、直接丢弃（DiscardPolicy）</li>
<li>2、丢弃队列中最老的任务(DiscardOldestPolicy)。</li>
<li>3、抛异常(AbortPolicy)</li>
<li>4、将任务分给调用线程来执行(CallerRunsPolicy)。</li>
</ul>
<h4 id="Runnable-Callable-Future和-FutureTask"><a href="/2019/10/20/Java/#Runnable-Callable-Future和-FutureTask" class="headerlink" title="Runnable, Callable, Future和 FutureTask"></a>Runnable, Callable, Future和 FutureTask</h4><blockquote>
<p>直接继承Thread, 和Runnable都不能返回执行结果, 就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。</p>
</blockquote>
<h5 id="Callable与Runnable"><a href="/2019/10/20/Java/#Callable与Runnable" class="headerlink" title="Callable与Runnable"></a>Callable与Runnable</h5><p>Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()：一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明了若干个submit方法的重载版本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<h5 id="Future"><a href="/2019/10/20/Java/#Future" class="headerlink" title="Future"></a>Future</h5><blockquote>
<p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。Future类位于java.util.concurrent包下，它是一个接口</p>
</blockquote>
<p>Future提供了三种功能：</p>
<p>　　1）判断任务是否完成；</p>
<p>　　2）能够中断任务；</p>
<p>　　3）能够获取任务执行结果。</p>
<p>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。</p>
<h5 id="FutureTask"><a href="/2019/10/20/Java/#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h5><blockquote>
<p>可以看出RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="锁"><a href="/2019/10/20/Java/#锁" class="headerlink" title="锁"></a>锁</h2><blockquote>
<p>常见的锁有synchronized、volatile、偏向锁、轻量级锁、重量级锁</p>
</blockquote>
<h3 id="死锁的原因"><a href="/2019/10/20/Java/#死锁的原因" class="headerlink" title="死锁的原因"></a>死锁的原因</h3><ol>
<li>互斥性: 某一段时间内, 某一资源只能一个线程使用</li>
<li>请求保持: A申请了一部分资源不足以运行,需要额外的其他资源,但又申请不到, 而其他线程又拿不到A保持的那份资源</li>
<li>不可剥夺: 进程未使用完之前,资源不可剥夺</li>
<li>循环等待: 进程资源形成环型链, 导致任何一个线程都拿不到运行所需的全部资源</li>
</ol>
<h3 id="CAS"><a href="/2019/10/20/Java/#CAS" class="headerlink" title="CAS"></a>CAS</h3><blockquote>
<p>CAS(Compare and Swap):  <strong>它的作用是将指定内存地址的内容与所给的某个值相比，如果相等，则将其内容替换为指令中提供的新值，如果不相等，则更新失败。这一比较并交换的操作是原子的，不可以被中断**</strong></p>
<p>==CAS是通过硬件命令保证了原子性==</p>
<p>（1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</p>
<p>（2）一个线程持有锁会导致其它所有需要此锁的线程挂起。</p>
<p>（3）如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</p>
<p>volatile是不错的机制，但是volatile不能保证原子性。因此对于同步最终还是要回到锁机制上来。独占锁是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁用到的机制就是CAS，Compare and Swap。</p>
</blockquote>
<h4 id="CAS导致的问题"><a href="/2019/10/20/Java/#CAS导致的问题" class="headerlink" title="CAS导致的问题"></a>CAS导致的问题</h4><ol>
<li><p><strong>ABA问题</strong></p>
<p>大多数情况下乐观锁的实现都会通过<strong>引入一个版本号标记</strong>这个对象，每次修改版本号都会变话，比如使用<strong>时间戳作为版本号</strong>，这样就可以很好的解决ABA问题</p>
<p>在JDK中提供了<strong>AtomicStampedReference</strong>类来解决这个问题，思路是一样的。这个类也维护了一个int类型的标记stamp，<strong>每次更新数据的时候顺带更新一下stamp</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 带有时间戳的原子类，不存在ABA问题，第二个参数就是默认时间戳，这里指定为0</span></span><br><span class="line">AtomicStampedReference&lt;Integer&gt; a2 = <span class="keyword">new</span> AtomicStampedReference&lt;Integer&gt;(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//可以看到使用AtomicStampedReference进行compareAndSet的时候，除了要验证数据，还要验证时间戳。</span></span><br><span class="line"> a2.compareAndSet(<span class="number">10</span>, <span class="number">11</span>, stamp, stamp + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><em>AtomicInteger的CAS原理</em></p>
<blockquote>
<p>​      通过查看AtomicInteger的源码可知， 通过申明一个<strong>volatile</strong> （内存锁定，同一时刻只有一个线程可以修改内存值）类型的变量，再加上unsafe.<strong>compareAndSwapInt</strong>的方法，来<strong>保证实现线程同步</strong>的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123; </span><br><span class="line">                    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update); </span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环时间长开销大</p>
<p>  <strong>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销</strong>。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。 </p>
</li>
<li><p>只能保证一个共享变量的原子操作</p>
<p>当<strong>对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时</strong>，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下<em>ij=2a，然后用CAS来操作ij</em>。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。 </p>
</li>
</ol>
<h3 id="synchronized、volatile的区别"><a href="/2019/10/20/Java/#synchronized、volatile的区别" class="headerlink" title="synchronized、volatile的区别"></a>synchronized、volatile的区别</h3><ul>
<li><strong>相同点</strong>：都保证了可见性</li>
<li><strong>不同点</strong> ： ==volatile不能保证原子性==，但是==synchronized能保证原子性且会发生阻塞==（在线程状态转换中详说），开销更大。</li>
</ul>
<h4 id="Volatile"><a href="/2019/10/20/Java/#Volatile" class="headerlink" title="Volatile"></a>Volatile</h4><blockquote>
<p><strong>volatile可以看做是一种synchronized的轻量级锁</strong>，他能够保证并发时，被它修饰的共享变量的可见性，当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p> volatile可以解决指令重排，它使用的是内存屏障进行解决的，所谓的内存屏障是一个cpu命令，它有两个作用保证特定的执行顺序，保证可见性，通过在volatile 指令前后增加内存屏障从而解决指令重排问题。 </p>
</blockquote>
<p><strong>实现原理:</strong></p>
<p>被volatile修饰的共享变量在进行写操作的时候</p>
<ul>
<li>1、将当前处理器缓存行的数据写回到系统内存。</li>
<li>2、这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li>
</ul>
<p><strong>使用场景:</strong></p>
<ul>
<li>1.访问变量不需要加锁（加锁的话使用volatile就没必要了）</li>
<li>2、对变量的写操作不依赖于当前值(因为他不能保证原子性)</li>
<li>3.该变量没有包含在具有其他变量的不变式中。</li>
</ul>
<p>一般我们会用来修饰状态标志；读写锁（读&gt;&gt;写，对写加锁，读不加锁）；DCL的单例模式中；volatile bean（例如放入HTTPSession中的对象）</p>
<h4 id="synchronized"><a href="/2019/10/20/Java/#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><blockquote>
<p>synchronized是并发编程中接触的最基本的同步工具，是一种<strong>重量级锁,也是 悲观锁</strong>，也是java内置的<strong>同步机制</strong>，首先我们知道synchronized提供了<strong>互斥性的</strong>语义和<strong>可见性</strong>，那么我们可以通过使用它来保证并发的安全。</p>
</blockquote>
<p><strong>synchronized三种用法</strong></p>
<ul>
<li><p>用于类上: </p>
<p>当使用synchronized修饰<strong>类静态方法</strong>时，那么当前<strong>加锁的级别就是类</strong>，当多个线程并发访问该类（所有实例对象）的同步方法以及同步代码块时，<strong>会进行同步</strong></p>
</li>
<li><p>用于代码块:</p>
<p>当使用synchronized修饰代码块时，那么当前<strong>加锁的</strong>级别就<strong>是synchronized（X）中配置的x对象实例</strong>，当多个线程并发访问该对象的同步方法、同步代码块以及当前的代码块时，会进行同步。</p>
<p>==使用同步代码块时要注意的是不要使用String类型对象，因为String常量池的存在，所以很容易导致出问题。==</p>
</li>
</ul>
<h3 id="Synchronized和CAS区别"><a href="/2019/10/20/Java/#Synchronized和CAS区别" class="headerlink" title="Synchronized和CAS区别"></a>Synchronized和CAS区别</h3><ul>
<li><strong>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则返回V。</strong>这是一种<strong>乐观锁的思路</strong>，它相信在它修改之前，没有其它线程去修改它；</li>
<li>而<strong>Synchronized是一种悲观锁</strong>，它认为在它修改之前，一定会有其它线程去修改它，悲观锁效率很低。下面来看一下AtomicInteger是如何利用CAS实现原子性操作的。</li>
</ul>
<h3 id="ReentrantLock"><a href="/2019/10/20/Java/#ReentrantLock" class="headerlink" title="ReentrantLock"></a><a href="https://blog.csdn.net/yanyan19880509/article/details/52345422">ReentrantLock</a></h3><blockquote>
<p>ReentrantLock实现了Lock接口, 支持两种获取锁的方式，一种是公平模型，一种是非公平模型。</p>
</blockquote>
<p><strong>公平锁模型：</strong></p>
<p>初始化时， state=0，表示无人抢占了打水权。这时候，村民A来打水(A线程请求锁)，占了打水权，把state+1，如下所示：</p>
 <img src="/2019/10/20/Java//20160828140603433" alt="线程A获取锁" style="zoom:50%;"> 

<p>线程A取得了锁，把 state原子性+1,这时候state被改为1，A线程继续执行其他任务，然后来了村民B也想打水（线程B请求锁），线程B无法获取锁，生成节点进行排队，如下图所示：</p>
 <img src="/2019/10/20/Java//20160828140648840" alt="线程B等待" style="zoom:50%;"> 

<p>初始化的时候，会生成一个空的头节点，然后才是B线程节点，这时候，如果线程A又请求锁，是否需要排队？答案当然是否定的，否则就直接死锁了。当A再次请求锁，就相当于是打水期间，同一家人也来打水了，是有特权的，这时候的状态如下图所示：</p>
 <img src="/2019/10/20/Java//20160828140726734" alt="可重入锁获取" style="zoom:50%;"> 

<p>到了这里，相信大家应该明白了什么是可重入锁了吧。就是一个线程在获取了锁之后，再次去获取了同一个锁，这时候仅仅是把状态值进行累加。如果线程A释放了一次锁，就成这样了：</p>
<img src="/2019/10/20/Java//20160828140803281" alt="线程A释放一次锁" style="zoom:50%;"> 

<p>仅仅是把状态值减了，只有线程A把此锁全部释放了，状态值减到0了，其他线程才有机会获取锁。当A把锁完全释放后，state恢复为0，然后会通知队列唤醒B线程节点，使B可以再次竞争锁。当然，如果B线程后面还有C线程，C线程继续休眠，除非B执行完了，通知了C线程。注意，当一个线程节点被唤醒然后取得了锁，对应节点会从队列中删除。</p>
<p><strong>非公平锁模型</strong></p>
<p>如果你已经明白了前面讲的公平锁模型，那么非公平锁模型也就非常容易理解了。当线程A执行完之后，要唤醒线程B是需要时间的，而且线程B醒来后还要再次竞争锁，所以如果在切换过程当中，来了一个线程C，那么线程C是有可能获取到锁的，如果C获取到了锁，B就只能继续乖乖休眠了。</p>
<h3 id="偏向锁-jvm内部"><a href="/2019/10/20/Java/#偏向锁-jvm内部" class="headerlink" title="偏向锁(jvm内部)"></a>偏向锁(jvm内部)</h3><ul>
<li>偏向锁（顾名思义，它会<strong>偏向于第一个访问锁的线程</strong>，如果在运行过程中，同步锁<strong>只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的</strong>，这种情况下，就会<strong>给线程加一个偏向锁</strong>）</li>
<li>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</li>
</ul>
<h3 id="轻量级锁-jvm"><a href="/2019/10/20/Java/#轻量级锁-jvm" class="headerlink" title="轻量级锁(jvm)"></a>轻量级锁(jvm)</h3><ul>
<li>轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁；</li>
<li>如果说<strong>轻量级锁</strong>是在<strong>无竞争的情况下使用CAS操作去消除同步使用的互斥量</strong>， 那偏向锁就是在无竞争的情况下把整个同步都消除掉， 连CAS操作都不做了。</li>
</ul>
<h3 id="自旋锁-jvm"><a href="/2019/10/20/Java/#自旋锁-jvm" class="headerlink" title="自旋锁(jvm)"></a>自旋锁(jvm)</h3><p>自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们<strong>只需要等一等</strong>（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就<strong>避免用户线程和内核的切换的消耗</strong></p>
<h3 id="jvm内部对锁的操作"><a href="/2019/10/20/Java/#jvm内部对锁的操作" class="headerlink" title="jvm内部对锁的操作"></a>jvm内部对锁的操作</h3><p>如果已经存在偏向锁了，则会尝试获取轻量级锁，如果以上两种都失败，则启用自旋锁，如果自旋也没有获取到锁，则使用重量级锁，没有获取到锁的线程阻塞挂起，直到持有锁的线程执行完同步块唤醒他们；</p>
<p><strong>偏向锁是在无锁争用的情况下使用的</strong>，也就是同步开在当前线程没有执行完之前，没有其它线程会执行该同步快，一旦有了第二个线程的争用，偏向锁就会升级为轻量级锁，一点有两个以上线程争用，就会升级为重量级锁；如果线程争用激烈，那么应该禁用偏向锁。</p>
<h3 id="synchronized实现，lock实现，有何区别"><a href="/2019/10/20/Java/#synchronized实现，lock实现，有何区别" class="headerlink" title="synchronized实现，lock实现，有何区别"></a>synchronized实现，lock实现，有何区别</h3><img src="/2019/10/20/Java//20180904143958577.png" alt="è¿éåå¾çæè¿°" style="zoom: 67%;">

<h2 id="JUC"><a href="/2019/10/20/Java/#JUC" class="headerlink" title="JUC"></a>JUC</h2><blockquote>
<p>Unsafe类是在sun.misc包下，不属于Java标准。但是很多Java的基础类库，包括一些被广泛使用的高性能开发库都是基于Unsafe类开发的，比如Netty、Cassandra、Hadoop、Kafka等。Unsafe类在提升Java运行效率，增强Java语言底层操作能力方面起了很大的作用。</p>
<p>Unsafe类使Java拥有了像C语言的指针一样操作内存空间的能力，<strong>同时也带来了指针的问题</strong>。过度的使用Unsafe类会使得出错的几率变大，因此Java官方并不建议使用的，官方文档也几乎没有。<br>通常我们最好也不要使用Unsafe类，除非有明确的目的，并且也要对它有深入的了解才行。</p>
</blockquote>
<h3 id="J-U-C-AQS"><a href="/2019/10/20/Java/#J-U-C-AQS" class="headerlink" title="J.U.C - AQS"></a>J.U.C - AQS</h3><p>java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。</p>
<h3 id="CountDownLatch"><a href="/2019/10/20/Java/#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><blockquote>
<p>用来控制一个或者多个线程等待多个线程。</p>
<p>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</p>
</blockquote>
<img src="/2019/10/20/Java//ba078291-791e-4378-b6d1-ece76c2f0b14.png" alt="img" style="zoom: 67%;">



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownLatchExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">"run.."</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();<span class="comment">//当前线程需要等待Countdownlatch值为0才会苏醒继续执行</span></span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CyclicBarrier"><a href="/2019/10/20/Java/#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><blockquote>
<p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p>
<p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p>
</blockquote>
<p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p>
<p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2019/10/20/Java//f71af66b-0d54-4399-a44b-f47b58321984.png" alt="img" style="zoom:67%;">



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">"before.."</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">"after.."</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Semaphore"><a href="/2019/10/20/Java/#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><blockquote>
<p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p>
</blockquote>
<p>以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> clientCount = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalRequestCount = <span class="number">10</span>;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(clientCount);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.print(semaphore.availablePermits() + <span class="string">" "</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2 1 2 2 2 2 2 1 2 2</span></span><br></pre></td></tr></table></figure>

<h3 id="基本类型原子类"><a href="/2019/10/20/Java/#基本类型原子类" class="headerlink" title="基本类型原子类"></a>基本类型原子类</h3><p>concurrent 包中提供了Java基本类型的原子操作封装类—–只要类名包含了Atomic关键字都是用于迸发的类型的封装</p>
<p>如: AtomicInteger, AtomicLong, AtomicIntegerArray, AtomicBoolean, AtomicReference, … 等等</p>
<p><strong>以AtomicInteger为例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 其中getIntVolatile和compareAndSwapInt都是native方法</span></span><br><span class="line"><span class="comment"> * getIntVolatile是获取当前的期望值</span></span><br><span class="line"><span class="comment"> * compareAndSwapInt就是我们平时说的CAS(compare and swap)，通过比较如果内存区的值没有改变，那么就用新值直接给该内存区赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong, <span class="keyword">int</span> paramInt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    i = getIntVolatile(paramObject, paramLong);</span><br><span class="line">  &#125; <span class="keyword">while</span> (!compareAndSwapInt(paramObject, paramLong, i, i + paramInt));</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>incrementAndGet</code>是将自增后的值返回，还有一个方法<code>getAndIncrement</code>是将自增前的值返回，分别对应<code>++i</code>和<code>i++</code>操作。同样的<code>decrementAndGe</code>t和<code>getAndDecrement</code>则对<code>--i</code>和<code>i--</code>操作。</p>
<h3 id="并发容器"><a href="/2019/10/20/Java/#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><blockquote>
<p>哈希表非常高效，复杂度为O(1)的数据结构，在Java开发中，我们最常见到最频繁使用的就是HashMap和HashTable，但是在线程竞争激烈的并发场景中使用都不够合理,会导致线程安全问题</p>
</blockquote>
<h4 id="HashMap"><a href="/2019/10/20/Java/#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ol>
<li><p><strong>关于位运算</strong> </p>
<p>关于位运算,左移一位就是×2倍的值,  位运算之高效，如下文在本来可以求模运算的时候，也换用位运算提高运算速度 </p>
</li>
<li><p><strong>为何要用2的幂次作为其容量</strong> </p>
<p>为了追求速度与效率，计算key的bucket进行hash计算的时候把取模运算转换为位运算，而当容量一定是2^n时：</p>
<p><strong>h &amp; (length - 1) 等价与 h % length</strong>，但他们是等价（效果）不等效（效率）的，其效果是计算h与length的模</p>
</li>
<li><p><strong>负载因子默认常量：</strong></p>
<p>static final floatDEFAULT_LOAD_FACTOR=0.75f;</p>
</li>
<li><p><strong>hash运算</strong> (为什么长度要是2的原因)</p>
<p>左边两组是数组长度为16（2的4次方），右边两组是数组长度为15。两组的hashcode均为8和9，但是很明显，当它们和1110“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到同一个链表上，那么查询的时候就需要遍历这个链表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hashcode的值会与14（1110）进行“与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！ </p>
 <img src="/2019/10/20/Java//4b3732d6-fb5f-369b-b50d-e8b8325c69d4.jpg" alt="点击查看原始大小图片" style="zoom:67%;"> 
</li>
<li><p><strong>hashmap什么时候进行扩容呢？</strong></p>
<p><strong>当hashmap中的元素个数超过数组大小loadFactor时</strong>，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过160.75=12的时候，就把数组的大小扩展为2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能.</p>
</li>
</ol>
<p>HashMap是<strong>线程不安全</strong></p>
<ul>
<li>扩容时可能造成(因为采用了倒插法导致了死循环链表,所以线程不安全-&gt; <strong>1.8采用了顺插法解决了这个问题)</strong></li>
<li>结果覆盖问题(多线程环境下,在同一个桶内插入数据,会拿到头节点,若A对头节点修改值后,b不知道又修改则覆盖了原值)</li>
</ul>
<h4 id="HashTable"><a href="/2019/10/20/Java/#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><p>HashTable和HashMap的实现原理几乎一样，差别无非是<strong>1.HashTable不允许key和value为null；2.HashTable是线程安全的。</strong>但是HashTable线程安全的策略实现代价却太大了，简单粗暴，get/put所有相关操作都是synchronized的，这相当于给整个哈希表加了一把<strong>大锁</strong>，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作<strong>串行化</strong>，在==竞争激烈的并发场景中性能就会非常差==。</p>
<img src="/2019/10/20/Java//1024555-20170514173954488-1353945142-1566995384603.png" alt="img" style="zoom:67%;">

<p>HashTable性能差主要是由于所有操作需要竞争同一把锁，而如果容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。这就是ConcurrentHashMap所采用的”<strong>分段锁</strong>“思想。</p>
<img src="/2019/10/20/Java//1024555-20170514174100832-1891630860.png" alt="img" style="zoom:67%;">

<ul>
<li><p>put的主要逻辑也就两步：</p>
<p><strong>put方法是要加锁的</strong>,  　若c超出阈值threshold，需要扩容并rehash。扩容后的容量是当前容量的2倍。这样可以最大程度避免之前散列好的entry重新散列，具体在另一篇文章中有详细分析，不赘述。扩容并rehash的这个过程是比较消耗资源的。</p>
<ul>
<li>*<em>1.定位segment并确保定位的Segment已初始化 *</em></li>
<li><strong>2.调用Segment的put方法。</strong></li>
</ul>
</li>
<li><p><strong>get方法</strong> 先定位Segment，再定位HashEntry</p>
</li>
<li><p><strong>无需加锁，由于其中涉及到的共享变量都使用volatile修饰，volatile可以保证内存可见性，所以不会读取到过期数据。</strong></p>
</li>
</ul>
<h4 id="Vector"><a href="/2019/10/20/Java/#Vector" class="headerlink" title="Vector"></a>Vector</h4><h5 id="1-同步-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-1-同步"><a href="/2019/10/20/Java/#1-同步-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-1-同步" class="headerlink" title="[1. 同步](https://cyc2018.github.io/CS-Notes/#/notes/Java 容器?id=_1-同步)"></a>[1. 同步](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 容器?id=_1-同步)</h5><p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h5 id="2-扩容-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-2-扩容-1"><a href="/2019/10/20/Java/#2-扩容-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-2-扩容-1" class="headerlink" title="[2. 扩容](https://cyc2018.github.io/CS-Notes/#/notes/Java 容器?id=_2-扩容-1)"></a>[2. 扩容](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 容器?id=_2-扩容-1)</h5><p>Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>调用没有 capacityIncrement 的构造函数时，capacityIncrement 值被设置为 0，也就是说默认情况下 Vector 每次扩容时容量都会翻倍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h5 id="3-与-ArrayList-的比较-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-3-与-arraylist-的比较"><a href="/2019/10/20/Java/#3-与-ArrayList-的比较-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-3-与-arraylist-的比较" class="headerlink" title="[3. 与 ArrayList 的比较](https://cyc2018.github.io/CS-Notes/#/notes/Java 容器?id=_3-与-arraylist-的比较)"></a>[3. 与 ArrayList 的比较](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 容器?id=_3-与-arraylist-的比较)</h5><ul>
<li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li>
<li>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。</li>
</ul>
<h5 id="4-替代方案-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-4-替代方案"><a href="/2019/10/20/Java/#4-替代方案-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-4-替代方案" class="headerlink" title="[4. 替代方案](https://cyc2018.github.io/CS-Notes/#/notes/Java 容器?id=_4-替代方案)"></a>[4. 替代方案](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 容器?id=_4-替代方案)</h5><p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; synList = Collections.synchronizedList(list);Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>



<h4 id="CopyOnWriteList"><a href="/2019/10/20/Java/#CopyOnWriteList" class="headerlink" title="CopyOnWriteList"></a>CopyOnWriteList</h4><h4 id="读写分离"><a href="/2019/10/20/Java/#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p>
<p><strong>写操作需要加锁，防止并发写入时导致写入数据丢失。</strong></p>
<p>写操作结束之后需要把原始数组指向新的复制数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="适用场景-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-适用场景"><a href="/2019/10/20/Java/#适用场景-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-适用场景" class="headerlink" title="[适用场景](https://cyc2018.github.io/CS-Notes/#/notes/Java 容器?id=适用场景)"></a>[适用场景](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 容器?id=适用场景)</h3><p>CopyOnWriteArrayList 在<strong>写操作的同时允许读操作</strong>，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p>
<p>但是 CopyOnWriteArrayList 有其缺陷：</p>
<ul>
<li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li>
</ul>
<p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p>
<h2 id="JVM"><a href="/2019/10/20/Java/#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="Java内存模型"><a href="/2019/10/20/Java/#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><blockquote>
<p> Java 内存模型<strong>试图屏蔽各种硬件和操作系统的内存访问差异</strong>，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。 </p>
</blockquote>
<h4 id="主内存与工作内存"><a href="/2019/10/20/Java/#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h4><blockquote>
<p> 处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。 </p>
</blockquote>
<p>加入高速缓存带来了一个新的问题：缓存一致性。如果<strong>多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致</strong>，需要一些协议来解决这个问题。</p>
 <img src="/2019/10/20/Java//942ca0d2-9d5c-45a4-89cb-5fd89b61913f.png" alt="img" style="zoom: 50%;"> 

<p> <strong>所有的变量都存储在主内存中，每个线程还有自己的工作内存</strong>，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。  <strong>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成</strong> (共享内存)</p>
<h4 id="内存间交互操作"><a href="/2019/10/20/Java/#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h4><p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。</p>
<img src="/2019/10/20/Java//8b7ebbad-9604-4375-84e3-f412099d170c.png" alt="img" style="zoom: 50%;">



<ul>
<li><strong>read</strong>：把一个变量的值从主内存传输到工作内存中</li>
<li><strong>load</strong>：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li>
<li>use：把工作内存中一个变量的值传递给执行引擎</li>
<li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li>
<li><strong>store</strong>：把工作内存的一个变量的值传送到主内存中</li>
<li><strong>write</strong>：在 store 之后执行，把 store 得到的值放入主内存的变量中</li>
<li><strong>lock</strong>：作用于主内存的变量</li>
<li><strong>unlock</strong>: 作用于主内存的变量</li>
</ul>
<h3 id="内存模型三大特性"><a href="/2019/10/20/Java/#内存模型三大特性" class="headerlink" title="内存模型三大特性"></a>内存模型三大特性</h3><h4 id="1-原子性"><a href="/2019/10/20/Java/#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h4><p><strong>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性</strong>，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 <strong>volatile(可见性,立即同步)</strong> 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。</p>
<p>有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。</p>
<p>为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。</p>
<p>下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 <strong>T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值</strong>。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 <strong>load、assign、store 这些单个操作具备原子性</strong>。</p>
<img src="/2019/10/20/Java//2797a609-68db-4d7b-8701-41ac9a34b14f.jpg" alt="img" style="zoom:50%;">



<p>AtomicInteger 能保证多个线程修改的原子性。</p>
<img src="/2019/10/20/Java//dd563037-fcaa-4bd8-83b6-b39d93a12c77.jpg" alt="img" style="zoom:50%;">



<p>使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger cnt = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。<strong>它对应的内存间交互操作为：lock 和 unlock</strong>，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicSynchronizedExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-可见性"><a href="/2019/10/20/Java/#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h4><p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。</p>
<p>主要有三种实现可见性的方式：</p>
<ul>
<li>volatile</li>
<li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li>
<li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</li>
</ul>
<p>对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。</p>
<h4 id="3-有序性"><a href="/2019/10/20/Java/#3-有序性" class="headerlink" title="3. 有序性"></a>3. 有序性</h4><p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，<strong>重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</strong></p>
<p>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即<strong>重排序时不能把后面的指令放到内存屏障之前。</strong></p>
<p>也<strong>可以通过 synchronized 来保证有序性</strong>，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。</p>
<h3 id="先行发生原则"><a href="/2019/10/20/Java/#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p>
<h4 id="1-单一线程原则"><a href="/2019/10/20/Java/#1-单一线程原则" class="headerlink" title="1. 单一线程原则"></a>1. 单一线程原则</h4><blockquote>
<p>Single Thread rule</p>
</blockquote>
<p>在一个线程内，在程序前面的操作先行发生于后面的操作。</p>
<img src="/2019/10/20/Java//874b3ff7-7c5c-4e7a-b8ab-a82a3e038d20.png" alt="img" style="zoom:67%;">

<h4 id="管程锁定规则"><a href="/2019/10/20/Java/#管程锁定规则" class="headerlink" title="管程锁定规则"></a>管程锁定规则</h4><blockquote>
<p>Monitor Lock Rule</p>
</blockquote>
<p>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</p>
<img src="/2019/10/20/Java//8996a537-7c4a-4ec8-a3b7-7ef1798eae26.png" alt="img" style="zoom:67%;">

<h4 id="3-volatile-变量规则"><a href="/2019/10/20/Java/#3-volatile-变量规则" class="headerlink" title="3. volatile 变量规则"></a>3. volatile 变量规则</h4><blockquote>
<p>Volatile Variable Rule</p>
</blockquote>
<p>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</p>
<img src="/2019/10/20/Java//942f33c9-8ad9-4987-836f-007de4c21de0.png" alt="img" style="zoom:67%;">

<h4 id="4-线程启动规则"><a href="/2019/10/20/Java/#4-线程启动规则" class="headerlink" title="4. 线程启动规则"></a>4. 线程启动规则</h4><blockquote>
<p>Thread Start Rule</p>
</blockquote>
<p>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</p>
<img src="/2019/10/20/Java//6270c216-7ec0-4db7-94de-0003bce37cd2.png" alt="img" style="zoom:67%;">

<h4 id="5-线程加入规则"><a href="/2019/10/20/Java/#5-线程加入规则" class="headerlink" title="5. 线程加入规则"></a>5. 线程加入规则</h4><blockquote>
<p>Thread Join Rule</p>
</blockquote>
<p>Thread 对象的结束先行发生于 join() 方法返回。</p>
<img src="/2019/10/20/Java//233f8d89-31d7-413f-9c02-042f19c46ba1.png" alt="img" style="zoom:67%;">

<h4 id="6-线程中断规则"><a href="/2019/10/20/Java/#6-线程中断规则" class="headerlink" title="6. 线程中断规则"></a>6. 线程中断规则</h4><blockquote>
<p>Thread Interruption Rule</p>
</blockquote>
<p>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</p>
<h4 id="7-对象终结规则"><a href="/2019/10/20/Java/#7-对象终结规则" class="headerlink" title="[7. 对象终结规则"></a>[7. 对象终结规则</h4><blockquote>
<p>Finalizer Rule</p>
</blockquote>
<p>一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</p>
<h4 id="8-传递性"><a href="/2019/10/20/Java/#8-传递性" class="headerlink" title="8. 传递性"></a>8. 传递性</h4><blockquote>
<p>Transitivity</p>
</blockquote>
<p>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</p>
<h3 id="内存分区"><a href="/2019/10/20/Java/#内存分区" class="headerlink" title="内存分区"></a>内存分区</h3><p><strong>内存分区:</strong> (总共分为: <strong>程序计数器, 堆, 栈, 方法区, 本地方法区</strong>)</p>
<ul>
<li><p><strong>线程私有区域:程序计数器、Java虚拟机栈、本地方法栈</strong></p>
<p>如果当前线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行 的是一个Native方法，这个计数器值为空。</p>
</li>
<li><p><strong>线程共享区域:Java堆(存储静态文件, 变量) , 方法区、运行时常量池</strong></p>
</li>
</ul>
<p><u><strong>当线程终止时，三者（虚拟机栈，本地方法栈和程序计数器）所占用的内存空间也会被释放掉, 因为它们是非共享区</strong></u></p>
<img src="/2019/10/20/Java//1216886-20170829193405046-797335140.png" alt="img" style="zoom: 67%;">

<h4 id="内存溢出"><a href="/2019/10/20/Java/#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><p><strong>原因:</strong>系统不能再分配你所需的内存空间</p>
<ol>
<li>一次性加载了过多的数据</li>
<li>对象不能被回收</li>
<li>代码bug导致死循环</li>
</ol>
<p>解决方案:</p>
<ol>
<li>使用内存分析工具jstat分析原因</li>
<li>调式是否是三方软件的漏洞</li>
<li>设置启动内存的大小</li>
</ol>
<h4 id="内存泄漏"><a href="/2019/10/20/Java/#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p><strong>原因:</strong>内存中有一块空间无法在被使用,又不能被清理掉,累积量大了之后就会导致内存泄漏</p>
<ol>
<li>代码漏洞导致常发性或者偶发性泄漏</li>
<li>对象不能被回收是根本原因</li>
</ol>
<p><strong>内存溢出和内存泄露的联系</strong><br>内存泄露会最终会导致内存溢出。<br>相同点：都会导致应用程序运行出现问题，性能下降或挂起。<br>不同点：</p>
<ul>
<li>1) 内存泄露是导致内存溢出的原因之一，内存泄露积累起来将导致内存溢出。</li>
<li>2) 内存泄露可以通过完善代码来避免，内</li>
</ul>
<h2 id="GC"><a href="/2019/10/20/Java/#GC" class="headerlink" title="GC"></a>GC</h2><h3 id="GC算法和机制"><a href="/2019/10/20/Java/#GC算法和机制" class="headerlink" title="GC算法和机制"></a>GC算法和机制</h3><ul>
<li><strong>机制</strong>: 标记清除, 引用计数, 停止-复制(程序暂停执行)</li>
<li><strong>算法</strong>: 引用计数法, 根搜索算法, 标记-清除算法, 复制算法 Copying, 标记整理算法</li>
</ul>
<h3 id="GC算法"><a href="/2019/10/20/Java/#GC算法" class="headerlink" title="GC算法"></a>GC算法</h3><p>java语言规范没有明确的说明JVM 使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做两件基本事情：</p>
<p>（1）发现无用的信息对象；</p>
<p>（2）回收将无用对象占用的内存空间。使该空间可被程序再次使用。</p>
<h4 id="1-引用计数法"><a href="/2019/10/20/Java/#1-引用计数法" class="headerlink" title="1. 引用计数法"></a>1. 引用计数法</h4><p>堆中每个对象实例都有一个引用计数。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。</p>
<h6 id="优点"><a href="/2019/10/20/Java/#优点" class="headerlink" title="优点:"></a>优点:</h6><p>引用计数器可以很快的额执行, 交织在程序运行中,对程序需要不被长时间打断的<strong>实时环境比较有利</strong></p>
<h6 id="缺点"><a href="/2019/10/20/Java/#缺点" class="headerlink" title="缺点:"></a>缺点:</h6><p>无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyObject object1 = <span class="keyword">new</span> MyObject();</span><br><span class="line">        MyObject object2 = <span class="keyword">new</span> MyObject();</span><br><span class="line">          </span><br><span class="line">        object1.object = object2;</span><br><span class="line">        object2.object = object1;</span><br><span class="line">          </span><br><span class="line">        object1 = <span class="keyword">null</span>;</span><br><span class="line">        object2 = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-tracing算法-Tracing-Collector-或-标记-清除算法-mark-and-sweep"><a href="/2019/10/20/Java/#2-tracing算法-Tracing-Collector-或-标记-清除算法-mark-and-sweep" class="headerlink" title="2. tracing算法(Tracing Collector) 或 标记-清除算法(mark and sweep)"></a>2. tracing算法(Tracing Collector) 或 标记-清除算法(mark and sweep)</h4><img src="/2019/10/20/Java//7178f37egw1etbmyb4jugj20ku0ajmy0.jpg" alt="img" style="zoom:67%;">

<p>从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。</p>
<p><strong>java中可作为GC Root的对象有</strong></p>
<p>1.虚拟机栈中引用的对象（本地变量表）</p>
<p>2.方法区中静态属性引用的对象</p>
<p>3.方法区中常量引用的对象</p>
<p>4.本地方法栈中引用的对象（Native对象)</p>
<h5 id="2-2-1-标记-清除算法"><a href="/2019/10/20/Java/#2-2-1-标记-清除算法" class="headerlink" title="2.2.1 标记-清除算法"></a>2.2.1 标记-清除算法</h5><p>标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如图所示</p>
<img src="/2019/10/20/Java//7178f37egw1etbmyakm6pj20fi0crmxm.jpg" alt="img" style="zoom:67%;">

<h5 id="2-2-2-compacting算法-或-标记-整理算法"><a href="/2019/10/20/Java/#2-2-2-compacting算法-或-标记-整理算法" class="headerlink" title="2.2.2 compacting算法 或 标记-整理算法"></a>2.2.2 compacting算法 或 标记-整理算法</h5><p>标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，<strong>会将所有的存活对象往左端空闲空间移动</strong>，并更新对应的指针,解决了内存碎片的问题.</p>
<h5 id="2-2-3copying算法-Compacting-Collector"><a href="/2019/10/20/Java/#2-2-3copying算法-Compacting-Collector" class="headerlink" title="2.2.3copying算法(Compacting Collector)"></a>2.2.3copying算法(Compacting Collector)</h5><p>基于copying算法的垃圾 收集就从根集中<strong>扫描活动对象</strong>，并将每个 <strong>活动对象复制到空闲面</strong>(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象面和空闲区域面，在对象面与空闲区域面的切换过程中，==程序暂停执行==。</p>
<h5 id="2-3-4-generation算法-Generational-Collector-分代回收"><a href="/2019/10/20/Java/#2-3-4-generation算法-Generational-Collector-分代回收" class="headerlink" title="2.3.4 generation算法(Generational Collector)分代回收"></a>2.3.4 generation算法(Generational Collector)分代回收</h5><p>分代的垃圾回收策略，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的</strong>。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。</p>
<img src="/2019/10/20/Java//7178f37egw1etbmycakylj20fn08kgmb.jpg" alt="img" style="zoom:67%;">



<p>Java中的对是jvm所管理的最大的一块内存空间, 主要用于粗放各种类的实例对象.</p>
<p>在Java中堆被分成两个不同的区域: </p>
<p><strong>1. 新生代(young)</strong></p>
<blockquote>
<p>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。</p>
</blockquote>
<p><strong>存在区域</strong>:Eden, From Survivor, To Survivor</p>
<p>回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。</p>
<p>当<strong>survivor1区不足</strong>以存放 eden和survivor0的存活对象时，就<strong>将存活对象直接存放到老年代</strong>。若是<strong>老年代</strong>也<strong>满了</strong>就会<strong>触发</strong>一次<strong>Full GC</strong>，也就是==新生代、老年代都进行回收==</p>
<p><strong>2. 老年代(old)</strong></p>
<blockquote>
<p>在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p>
</blockquote>
<p>当<strong>老年代内存满时触发Major GC即Full GC</strong>，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。</p>
<img src="http://www.blogjava.net/images/blogjava_net/fancydeepin/JVM/%E5%A0%86%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B2.png" alt="img" style="zoom: 67%;">

<p>堆大小=新生代+老年代,  堆的大小可以通过参数 –Xms、-Xmx 来指定。</p>
<p><strong>JVM</strong> 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。<br>因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。</p>
<ol start="3">
<li><p>持久代（Permanent Generation）</p>
<p>用于存放<strong>静态文件</strong>，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。</p>
</li>
</ol>
<h3 id="GC（垃圾收集器）"><a href="/2019/10/20/Java/#GC（垃圾收集器）" class="headerlink" title="GC（垃圾收集器）"></a>GC（垃圾收集器）</h3><img src="/2019/10/20/Java//7178f37egw1etbmycjfvoj20e40engmi.jpg" alt="img" style="zoom:67%;">

<ul>
<li><p><strong>Serial收集器（复制算法)</strong></p>
<p>新生代单线程收集器，标记和清理都是单线程，优点是简单高效。</p>
</li>
<li><p><strong>Serial Old收集器(标记-整理算法)</strong></p>
<p>老年代单线程收集器，Serial收集器的老年代版本。</p>
</li>
<li><p><strong>ParNew收集器(停止-复制算法)</strong>　</p>
<p>新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。</p>
</li>
<li><p><strong>Parallel Scavenge收集器(停止-复制算法)</strong></p>
<p>并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。</p>
</li>
<li><p><strong>Parallel Old收集器(停止-复制算法)</strong></p>
<p>Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先</p>
</li>
<li><p><strong>CMS(Concurrent Mark Sweep)收集器（标记-清理算法）</strong></p>
<p>高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择</p>
</li>
</ul>
<h3 id="GC的执行机制"><a href="/2019/10/20/Java/#GC的执行机制" class="headerlink" title="GC的执行机制"></a>GC的执行机制</h3><p>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。</p>
<ul>
<li><h5 id="Scavenge-GC"><a href="/2019/10/20/Java/#Scavenge-GC" class="headerlink" title="Scavenge GC"></a><strong>Scavenge GC</strong></h5><p>一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p>
</li>
<li><h5 id="Full-GC"><a href="/2019/10/20/Java/#Full-GC" class="headerlink" title="Full GC"></a><strong>Full GC</strong></h5><p>对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：</p>
<ul>
<li>1.年老代（Tenured）被写满</li>
<li>2.持久代（Perm）被写满</li>
<li>3.<strong>System.gc()</strong>被显示调用</li>
<li>4.上一次GC之后Heap的各域分配策略动态变化</li>
</ul>
</li>
</ul>
<h3 id="Java有了GC同样会出现内存泄露问题"><a href="/2019/10/20/Java/#Java有了GC同样会出现内存泄露问题" class="headerlink" title="Java有了GC同样会出现内存泄露问题"></a>Java有了GC同样会出现内存泄露问题</h3><ul>
<li>1.静态集合类像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放，因为他们也将一直被Vector等应用着。</li>
<li>2.各种连接，数据库连接，网络连接，IO连接等没有显示调用close关闭，不被GC回收导致内存泄露。</li>
<li>3.监听器的使用，在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露。</li>
</ul>
<h3 id="JVM中的安全点"><a href="/2019/10/20/Java/#JVM中的安全点" class="headerlink" title="JVM中的安全点"></a>JVM中的安全点</h3><blockquote>
<h4 id="在-JVM-中如何判断对象可以被回收-一文中，我们知道-HotSpot-虚拟机采取的是可达性分析算法。即通过-GC-Roots-枚举判定待回收的对象。"><a href="/2019/10/20/Java/#在-JVM-中如何判断对象可以被回收-一文中，我们知道-HotSpot-虚拟机采取的是可达性分析算法。即通过-GC-Roots-枚举判定待回收的对象。" class="headerlink" title="在 JVM 中如何判断对象可以被回收 一文中，我们知道 HotSpot 虚拟机采取的是可达性分析算法。即通过 GC Roots 枚举判定待回收的对象。"></a>在 JVM 中如何判断对象可以被回收 一文中，我们知道 HotSpot 虚拟机采取的是可达性分析算法。即通过 GC Roots 枚举判定待回收的对象。</h4></blockquote>
<p>那么，首先要找到哪些是 GC Roots。</p>
<p>有两种查找 GC Roots 的方法：</p>
<ul>
<li>一种是遍历方法区和栈区查找（保守式 GC）。</li>
<li>一种是通过 OopMap 数据结构来记录 GC Roots 的位置（准确式 GC）。</li>
</ul>
<p>很明显，保守式 GC 的成本太高。准确式 GC 的优点就是能够让虚拟机快速定位到 GC Roots。</p>
<p>对应 OopMap 的位置即可作为一个安全点（Safe Point）。</p>
<p>在执行 GC 操作时，所有的工作线程必须停顿，这就是所谓的”Stop-The-World”。</p>
<p>为什么呢？</p>
<p>因为可达性分析算法必须是在一个确保一致性的内存快照中进行。如果在分析的过程中对象引用关系还在不断变化，分析结果的准确性就不能保证。</p>
<p>安全点意味着在这个点时，所有工作线程的状态是确定的，JVM 就可以安全地执行 GC 。</p>
<h3 id="如何选定安全点"><a href="/2019/10/20/Java/#如何选定安全点" class="headerlink" title="如何选定安全点"></a>如何选定安全点</h3><p>安全点太多，GC 过于频繁，增大运行时负荷；安全点太少，GC 等待时间太长。</p>
<p>一般会在如下几个位置选择安全点：</p>
<ul>
<li>循环的末尾</li>
<li>方法临返回前</li>
<li>调用方法之后</li>
<li>抛异常的位置</li>
</ul>
<p><strong>为什么选定这些位置作为安全点：</strong></p>
<p>主要的目的就是<strong>避免程序长时间无法进入 Safe Point</strong>。比如 JVM 在做 GC 之前要等所有的应用线程进入安全点，如果有一个线程一直没有进入安全点，就会<strong>导致 GC 时 JVM 停顿时间延长</strong>。比如这里，超大的循环导致执行 GC 等待时间过长。</p>
<h3 id="如何在-GC-发生时，所有线程都跑到最近的-Safe-Point-上再停下来？"><a href="/2019/10/20/Java/#如何在-GC-发生时，所有线程都跑到最近的-Safe-Point-上再停下来？" class="headerlink" title="如何在 GC 发生时，所有线程都跑到最近的 Safe Point 上再停下来？"></a>如何在 GC 发生时，所有线程都跑到最近的 Safe Point 上再停下来？</h3><p>主要有两种方式：</p>
<ul>
<li>抢断式中断：在 GC 发生时，首先中断所有线程，如果发现线程未执行到 Safe Point，就恢复线程让其运行到 Safe Point 上。</li>
<li>主动式中断：在 GC 发生时，不直接操作线程中断，而是简单地设置一个标志，让各个线程执行时主动轮询这个标志，发现中断标志为真时就自己中断挂起。</li>
</ul>
<p><u>JVM 采取的就是<strong>主动式中断</strong></u>。轮询标志的地方和安全点是重合的。</p>
<h3 id="安全区域又是什么？"><a href="/2019/10/20/Java/#安全区域又是什么？" class="headerlink" title="安全区域又是什么？"></a>安全区域又是什么？</h3><p>Safe Point 是对正在执行的线程设定的, 如果<strong>一个线程处于 Sleep 或中断状态，它就不能响应 JVM 的中断请求</strong>，再运行到 Safe Point 上。因此 JVM 引入了 Safe Region。</p>
<p>Safe Region 是指在一段代码片段中，引用关系不会发生变化。在这个区域内的任意地方开始 GC 都是安全的。线程在进入 Safe Region 的时候先标记自己已进入了 Safe Region，等到被唤醒时准备离开 Safe Region 时，先检查能否离开，如果 GC 完成了，那么线程可以离开，否则它必须等待直到收到安全离开的信号为止。</p>
<h2 id="分布式"><a href="/2019/10/20/Java/#分布式" class="headerlink" title="分布式"></a>分布式</h2><h3 id="单系统"><a href="/2019/10/20/Java/#单系统" class="headerlink" title="单系统"></a>单系统</h3><blockquote>
<p>所有的代码都在一个工程里，最多可能就是通过maven等构件工具拆分了一下代码工程模块，不同的模块可以放在不同的工程代码里。</p>
</blockquote>
<p>在部署的时候，可能就是直接在线上的几台机器里直接放到里面的tomcat下来运行。很多流量很小的企业内部系统，比如OA、CRM、财务等系统，甚至可能就直接在一台机器的tomcat下部署一下。然后直接配置一下域名解析，就可以让这个系统的可能几十个，或者几百个用户通过访问域名来使用这个软件了。</p>
<p><img src="/2019/10/20/Java//13394159-1ac3a7b4a8e6c0a6.webp" alt="img"></p>
<p>只不过为了所谓的“高可用”，可能一般会部署两台机器，前面加一层<strong>负载均衡设备</strong>，这样其中一个机器挂了，另外一个机器上还有一个系统可以用。</p>
<p><strong>但是团队越来越大，业务越来越复杂</strong>, 小团队你搞一个代码仓库，然后就一份代码，每个人都在自己本地写代码，最后把代码合并一下，做做测试，然后就直接部署基于Tomcat来就可以了。几十个人维护一个单块系统，大家在一个工程里写代码，大量的冲突以及代码合并都会让人崩溃。比如某个功能模块要上线了，但是他必须得把整个单块系统所有的功能都回归测试一遍才敢上线. 因为`<strong>大家的代码</strong>都在一个工程里，都是<strong>耦合在一起的</strong>，你修改了代码，必须全部测试一遍才能保证系统正常。</p>
<h3 id="分布式系统"><a href="/2019/10/20/Java/#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h3><p><strong>因此分布式出现</strong>：庞大系统分而治之</p>
<blockquote>
<p>这个时候就可以尝试把一个大的系统拆分为很多小的系统，甚至很多小的服务，然后几个人组成一个小组就专门维护其中一个小系统，或者每个人维护一个小服务。简单来说，就是分而治之，这样每个人可以专注维护自己的代码。</p>
</blockquote>
<p>不同的小系统自己开发、测试和上线，都不会跟别人耦合在一起，可以自己独立进行，非常的方便，大大简化了大规模系统的开发成本。</p>
<p>不同的<strong>子系统之间</strong>，就是<strong>通过接口互相来回调用</strong>，每个<strong>子系统都有自己的数据库</strong>，大家看下面的图。</p>
<img src="/2019/10/20/Java//13394159-1e816247147c8fef.webp" alt="img" style="zoom:67%;">

<h3 id="分布式系统所带来的技术问题"><a href="/2019/10/20/Java/#分布式系统所带来的技术问题" class="headerlink" title="分布式系统所带来的技术问题"></a>分布式系统所带来的技术问题</h3><blockquote>
<p>你的系统一旦分布式了之后，通信、缓存、消息、事务、锁、配置、日志、监控、会话，等等各种原来单块系统场景下很容易解决的问题，都会变得很复杂，需要引入大量外部的技术。</p>
</blockquote>
<ul>
<li><h5 id="1-分布式服务框架"><a href="/2019/10/20/Java/#1-分布式服务框架" class="headerlink" title="(1)分布式服务框架"></a>(1)分布式服务框架</h5><p>你如果要让不同的子系统或者服务之间互相通信，首先必须有一套分布式服务框架。也就是各个服务可以互相感知到对方在哪里，可以发送请求过去，可以通过HTTP或者RPC的方式。在这里，最常见的技术就是<strong>dubbo</strong>以及<strong>spring cloud</strong>，当然大厂一般都是自己有服务框架    </p>
</li>
<li><h5 id="2-分布式事务"><a href="/2019/10/20/Java/#2-分布式事务" class="headerlink" title="(2)分布式事务"></a>(2)分布式事务</h5><p>一旦你的系统拆分为了多个子系统之后，那么一个贯穿全局的分布式事务应该怎么来实现? 这个你需要了解<strong>TCC</strong>、<strong>最终一致性</strong>、<strong>2PC</strong>等分布式事务的实现方案和开源技术。</p>
</li>
<li><h5 id="3-分布式锁"><a href="/2019/10/20/Java/#3-分布式锁" class="headerlink" title="(3)分布式锁"></a>(3)分布式锁</h5><p>不同的系统之间如果需要在全局加锁获取某个资源的锁定，此时应该怎么来做? 毕竟大家不是在一个JVM里了，<strong>不可能用synchronized来在多个子系统之间实现锁</strong></p>
</li>
<li><h5 id="4-分布式缓存"><a href="/2019/10/20/Java/#4-分布式缓存" class="headerlink" title="(4)分布式缓存"></a>(4)分布式缓存</h5><p>如果你原来就是个<strong>单块系统</strong>，那么你其实是可以在<strong>单个JVM里进行本地缓存</strong>就可以了，比如搞一个HashMap来缓存一些数据。但是现在你有很多个子系统，他们如果要共享一个缓存，你应该怎么办?是不是需要引入<strong>Redis等缓存系统</strong>?</p>
</li>
<li><h5 id="5-分布式消息系统"><a href="/2019/10/20/Java/#5-分布式消息系统" class="headerlink" title="(5)分布式消息系统"></a>(5)分布式消息系统</h5><p>在单块系统内，就一个JVM进程内部，你可以用类似LinkedList之类的数据结构作为一个本地内存里的队列。</p>
<p>但是<strong>多个子系统之间要进行消息队列的传递</strong>呢?那是不是要引入类似<strong>RabbitMQ</strong>之类的<strong>分布式消息中间件</strong>?</p>
</li>
<li><h5 id="6-分布式搜索系统"><a href="/2019/10/20/Java/#6-分布式搜索系统" class="headerlink" title="(6)分布式搜索系统"></a>(6)分布式搜索系统</h5><p>如果在单块系统内，你可以比如在本地就基于Lucene来开发一个全文检索模块，但是如果是分布式系统下的很多子系统，你还能直接基于Lucene吗?　明显不行，你需要在系统里引入一个外部的分布式搜索系统，比如<strong>Elasticsearch</strong>。</p>
</li>
<li><h5 id="7-其他很多的技术"><a href="/2019/10/20/Java/#7-其他很多的技术" class="headerlink" title="(7)其他很多的技术"></a>(7)其他很多的技术</h5><p>比如说<strong>分布式配置中心、分布式日志中心、分布式监控告警中心、分布式会话</strong>，等等，都是分布式系统场景下你需要使用和了解的一些技术。因为沿用单块系统时代的那些技术已经不行了，比如说你单块系统的时候，直接在本地用一个properties文件存放自己的配置即可，日志也写到本地即可。</p>
</li>
</ul>

      </div>
      
        <br>
        


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-10-20T15:18:40+08:00">
  <a class='notlink'>
    <i class="fas fa-clock" aria-hidden="true"></i>
    <p>updated at Oct 20, 2019</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/IT/" rel="nofollow"><i class="fas fa-tag" aria-hidden="true"></i><p>IT</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" rel="nofollow"><i class="fas fa-tag" aria-hidden="true"></i><p>技术笔记</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Job/" rel="nofollow"><i class="fas fa-tag" aria-hidden="true"></i><p>Job</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Java/" rel="nofollow"><i class="fas fa-tag" aria-hidden="true"></i><p>Java</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="QQ好友" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=/2019/10/20/Java/&title=Java从基础到核心 | 蜗牛君&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="QQ空间" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=/2019/10/20/Java/&title=Java从基础到核心 | 蜗牛君&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="微博" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=/2019/10/20/Java/&title=Java从基础到核心 | 蜗牛君&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


      
      
          <div class="prev-next">
              
                  <section class="prev">
                      <span class="art-item-left">
                          <h6><i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;Previous</h6>
                          <h4>
                              <a href="/2019/10/20/Kafka%E9%9D%A2%E8%AF%95/" rel="prev" title="Kafka面试">
                                
                                    Kafka面试
                                
                              </a>
                          </h4>
                          
                              
                              <h6 class="tags">
                                  <a class="tag" href="/tags/IT/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> IT</a> <a class="tag" href="/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> 技术笔记</a> <a class="tag" href="/tags/Job/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> Job</a> <a class="tag" href="/tags/Kafka/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> Kafka</a>
                              </h6>
                          
                      </span>
                  </section>
              
              
                  <section class="next">
                      <span class="art-item-right" aria-hidden="true">
                          <h6>Next&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></h6>
                          <h4>
                              <a href="/2019/10/20/Redis%E9%9D%A2%E8%AF%95/" rel="prev" title="Redis面试">
                                  
                                      Redis面试
                                  
                              </a>
                          </h4>
                          
                              
                              <h6 class="tags">
                                  <a class="tag" href="/tags/IT/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> IT</a> <a class="tag" href="/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> 技术笔记</a> <a class="tag" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> 数据库</a> <a class="tag" href="/tags/Job/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> Job</a> <a class="tag" href="/tags/Redis/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> Redis</a>
                              </h6>
                          
                      </span>
                  </section>
              
          </div>
      
    </section>
  </article>



  <!-- 显示推荐文章和评论 -->



  






<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: 'Java从基础到核心',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
    
    
      
      
        
          
          
            
              <section class='widget author'>
  <div class='content pure'>
    
      <div class='avatar'>
        <img class='avatar' src='/assets/self.jpg'/>
      </div>
    
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml"
              class="social fas fa-rss flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:dmlys@live.com"
              class="social fas fa-envelope flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/ChanMango"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=118376074"
              class="social fas fa-headphones-alt flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

            
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
            
              
  <section class='widget toc-wrapper'>
    
<header class='pure'>
  <div><i class="fas fa-list fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;TOC</div>
  
    <!-- <div class='wrapper'><a class="s-toc rightBtn" rel="external nofollow noopener noreferrer" href="javascript:void(0)"><i class="fas fa-thumbtack fa-fw"></i></a></div> -->
  
</header>

    <div class='content pure'>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java基础核心"><span class="toc-text">Java基础核心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型"><span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本类型"><span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#包装类型"><span class="toc-text">包装类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存池-重要"><span class="toc-text">缓存池(!!!重要)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-https-cyc2018-github-io-CS-Notes-notes-Java-基础-id-二、string"><span class="toc-text">[String](https://cyc2018.github.io/CS-Notes/#/notes/Java 基础?id=二、string)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-Pool"><span class="toc-text">String Pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不可变的好处"><span class="toc-text">不可变的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-StringBuffer-and-StringBuilder"><span class="toc-text">String, StringBuffer and StringBuilder</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运算"><span class="toc-text">运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#参数传递"><span class="toc-text">参数传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#float与double"><span class="toc-text">float与double</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#隐式类型转换"><span class="toc-text">隐式类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch"><span class="toc-text">switch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#权限修饰符"><span class="toc-text">权限修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重写与重载"><span class="toc-text">重写与重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#equals"><span class="toc-text">equals()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashCode"><span class="toc-text">hashCode()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toString-NaN"><span class="toc-text">toString()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clone"><span class="toc-text">clone()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super"><span class="toc-text">super</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关键字"><span class="toc-text">关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static"><span class="toc-text">static</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反射"><span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类与接口"><span class="toc-text">抽象类与接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常"><span class="toc-text">异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型"><span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型类"><span class="toc-text">泛型类:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型接口"><span class="toc-text">泛型接口:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型方法"><span class="toc-text">泛型方法:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型面试题"><span class="toc-text">泛型面试题:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注解"><span class="toc-text">注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本容器"><span class="toc-text">基本容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特性"><span class="toc-text">特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-各版本的新特性"><span class="toc-text">Java 各版本的新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-与-C-的区别"><span class="toc-text">Java 与 C++ 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JRE-or-JDK"><span class="toc-text">JRE or JDK</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java高级"><span class="toc-text">Java高级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#队列"><span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#等待队列（Condition-Queue）"><span class="toc-text">等待队列（Condition Queue）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockingQueue"><span class="toc-text">BlockingQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见BlockingQueue"><span class="toc-text">常见BlockingQueue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缓存"><span class="toc-text">缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存能解决的问题"><span class="toc-text">缓存能解决的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#缓解数据库压力"><span class="toc-text">缓解数据库压力</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存的适用场景"><span class="toc-text">缓存的适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存三种模式"><span class="toc-text">缓存三种模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cache-Aside-更新模式"><span class="toc-text">Cache Aside 更新模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#避坑指南一"><span class="toc-text">避坑指南一</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#避坑指南二"><span class="toc-text">避坑指南二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#避坑指南三"><span class="toc-text">避坑指南三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Read-Write-Through-更新模式"><span class="toc-text">Read/Write Through 更新模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Read-Through"><span class="toc-text">Read Through</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Write-Through"><span class="toc-text">Write Through</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Write-Behind-Caching-更新模式"><span class="toc-text">Write Behind Caching 更新模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存失效策略"><span class="toc-text">缓存失效策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存淘汰策略"><span class="toc-text">缓存淘汰策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分布式缓存的常见问题"><span class="toc-text">分布式缓存的常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#缓存穿透"><span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缓存击穿"><span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缓存雪崩"><span class="toc-text">缓存雪崩</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设计模式"><span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#设计模式的六大原则及其含义"><span class="toc-text">设计模式的六大原则及其含义:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见模式及优缺点："><span class="toc-text">常见模式及优缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设计模式在实际场景的应用"><span class="toc-text">设计模式在实际场景的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring中用到了哪些设计模式"><span class="toc-text">==Spring中用到了哪些设计模式==</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis中用到了哪些设计模式"><span class="toc-text">==MyBatis中用到了哪些设计模式==</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代理模式-Proxy"><span class="toc-text">代理模式(Proxy)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类加载器"><span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ClassLoader"><span class="toc-text">ClassLoader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#来看看-loadClass-方法的代码：双亲委托机制"><span class="toc-text">来看看 loadClass 方法的代码：双亲委托机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO"><span class="toc-text">IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java的io，nio，bio区别"><span class="toc-text">Java的io，nio，bio区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-模型"><span class="toc-text">I/O 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#阻塞式-I-O"><span class="toc-text">阻塞式 I/O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#非阻塞式-I-O"><span class="toc-text">非阻塞式 I/O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O-复用"><span class="toc-text">I/O 复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#信号驱动-I-O"><span class="toc-text">信号驱动 I/O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异步-I-O-AIO"><span class="toc-text">异步 I/O (AIO)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#五大-I-O-模型比较"><span class="toc-text">五大 I/O 模型比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O-复用-详细讲解"><span class="toc-text">I/O 复用 详细讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#select"><span class="toc-text">select</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#poll"><span class="toc-text">poll</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#比较"><span class="toc-text">比较</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-功能"><span class="toc-text">1. 功能</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-速度"><span class="toc-text">2. 速度</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-可移植性"><span class="toc-text">3. 可移植性</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#epoll"><span class="toc-text">epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#工作模式"><span class="toc-text">工作模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#应用场景"><span class="toc-text">应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-select-应用场景"><span class="toc-text">1. select 应用场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-poll-应用场景"><span class="toc-text">2. poll 应用场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-epoll-应用场景"><span class="toc-text">3. epoll 应用场景</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程"><span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程和线程区别"><span class="toc-text">进程和线程区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#守护线程-amp-非守护线程"><span class="toc-text">守护线程&amp;非守护线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的状态转换"><span class="toc-text">线程的状态转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程安全"><span class="toc-text">线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要用线程池"><span class="toc-text">为什么要用线程池?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#线程中重要的几个类"><span class="toc-text">线程中重要的几个类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-Thread的弊端"><span class="toc-text">new Thread的弊端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java提供的四种线程池的好处在于："><span class="toc-text">Java提供的四种线程池的好处在于：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四种线程池"><span class="toc-text">四种线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#submit-和execute-的以及shutdown-和shutdownNow-的区别"><span class="toc-text">submit()和execute()的以及shutdown()和shutdownNow()的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RejectedExecutionHandler-线程池四种拒绝任务策略"><span class="toc-text">RejectedExecutionHandler 线程池四种拒绝任务策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Runnable-Callable-Future和-FutureTask"><span class="toc-text">Runnable, Callable, Future和 FutureTask</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Callable与Runnable"><span class="toc-text">Callable与Runnable</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Future"><span class="toc-text">Future</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FutureTask"><span class="toc-text">FutureTask</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁"><span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁的原因"><span class="toc-text">死锁的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS"><span class="toc-text">CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CAS导致的问题"><span class="toc-text">CAS导致的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized、volatile的区别"><span class="toc-text">synchronized、volatile的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Volatile"><span class="toc-text">Volatile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized"><span class="toc-text">synchronized</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized和CAS区别"><span class="toc-text">Synchronized和CAS区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock"><span class="toc-text">ReentrantLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#偏向锁-jvm内部"><span class="toc-text">偏向锁(jvm内部)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#轻量级锁-jvm"><span class="toc-text">轻量级锁(jvm)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自旋锁-jvm"><span class="toc-text">自旋锁(jvm)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jvm内部对锁的操作"><span class="toc-text">jvm内部对锁的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized实现，lock实现，有何区别"><span class="toc-text">synchronized实现，lock实现，有何区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JUC"><span class="toc-text">JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#J-U-C-AQS"><span class="toc-text">J.U.C - AQS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CountDownLatch"><span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CyclicBarrier"><span class="toc-text">CyclicBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Semaphore"><span class="toc-text">Semaphore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本类型原子类"><span class="toc-text">基本类型原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发容器"><span class="toc-text">并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap"><span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashTable"><span class="toc-text">HashTable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector"><span class="toc-text">Vector</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-同步-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-1-同步"><span class="toc-text">[1. 同步](https://cyc2018.github.io/CS-Notes/#/notes/Java 容器?id=_1-同步)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-扩容-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-2-扩容-1"><span class="toc-text">[2. 扩容](https://cyc2018.github.io/CS-Notes/#/notes/Java 容器?id=_2-扩容-1)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-与-ArrayList-的比较-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-3-与-arraylist-的比较"><span class="toc-text">[3. 与 ArrayList 的比较](https://cyc2018.github.io/CS-Notes/#/notes/Java 容器?id=_3-与-arraylist-的比较)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-替代方案-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-4-替代方案"><span class="toc-text">[4. 替代方案](https://cyc2018.github.io/CS-Notes/#/notes/Java 容器?id=_4-替代方案)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CopyOnWriteList"><span class="toc-text">CopyOnWriteList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读写分离"><span class="toc-text">读写分离</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#适用场景-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-适用场景"><span class="toc-text">[适用场景](https://cyc2018.github.io/CS-Notes/#/notes/Java 容器?id=适用场景)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java内存模型"><span class="toc-text">Java内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主内存与工作内存"><span class="toc-text">主内存与工作内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存间交互操作"><span class="toc-text">内存间交互操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存模型三大特性"><span class="toc-text">内存模型三大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-原子性"><span class="toc-text">1. 原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-可见性"><span class="toc-text">2. 可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-有序性"><span class="toc-text">3. 有序性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#先行发生原则"><span class="toc-text">先行发生原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-单一线程原则"><span class="toc-text">1. 单一线程原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#管程锁定规则"><span class="toc-text">管程锁定规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-volatile-变量规则"><span class="toc-text">3. volatile 变量规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-线程启动规则"><span class="toc-text">4. 线程启动规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-线程加入规则"><span class="toc-text">5. 线程加入规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-线程中断规则"><span class="toc-text">6. 线程中断规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-对象终结规则"><span class="toc-text">[7. 对象终结规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-传递性"><span class="toc-text">8. 传递性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存分区"><span class="toc-text">内存分区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#内存溢出"><span class="toc-text">内存溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存泄漏"><span class="toc-text">内存泄漏</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC"><span class="toc-text">GC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GC算法和机制"><span class="toc-text">GC算法和机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC算法"><span class="toc-text">GC算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-引用计数法"><span class="toc-text">1. 引用计数法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#优点"><span class="toc-text">优点:</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#缺点"><span class="toc-text">缺点:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-tracing算法-Tracing-Collector-或-标记-清除算法-mark-and-sweep"><span class="toc-text">2. tracing算法(Tracing Collector) 或 标记-清除算法(mark and sweep)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1-标记-清除算法"><span class="toc-text">2.2.1 标记-清除算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-2-compacting算法-或-标记-整理算法"><span class="toc-text">2.2.2 compacting算法 或 标记-整理算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-3copying算法-Compacting-Collector"><span class="toc-text">2.2.3copying算法(Compacting Collector)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-4-generation算法-Generational-Collector-分代回收"><span class="toc-text">2.3.4 generation算法(Generational Collector)分代回收</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC（垃圾收集器）"><span class="toc-text">GC（垃圾收集器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC的执行机制"><span class="toc-text">GC的执行机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Scavenge-GC"><span class="toc-text">Scavenge GC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Full-GC"><span class="toc-text">Full GC</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java有了GC同样会出现内存泄露问题"><span class="toc-text">Java有了GC同样会出现内存泄露问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM中的安全点"><span class="toc-text">JVM中的安全点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#在-JVM-中如何判断对象可以被回收-一文中，我们知道-HotSpot-虚拟机采取的是可达性分析算法。即通过-GC-Roots-枚举判定待回收的对象。"><span class="toc-text">在 JVM 中如何判断对象可以被回收 一文中，我们知道 HotSpot 虚拟机采取的是可达性分析算法。即通过 GC Roots 枚举判定待回收的对象。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何选定安全点"><span class="toc-text">如何选定安全点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何在-GC-发生时，所有线程都跑到最近的-Safe-Point-上再停下来？"><span class="toc-text">如何在 GC 发生时，所有线程都跑到最近的 Safe Point 上再停下来？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安全区域又是什么？"><span class="toc-text">安全区域又是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分布式"><span class="toc-text">分布式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单系统"><span class="toc-text">单系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分布式系统"><span class="toc-text">分布式系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分布式系统所带来的技术问题"><span class="toc-text">分布式系统所带来的技术问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-分布式服务框架"><span class="toc-text">(1)分布式服务框架</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-分布式事务"><span class="toc-text">(2)分布式事务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-分布式锁"><span class="toc-text">(3)分布式锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-分布式缓存"><span class="toc-text">(4)分布式缓存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-分布式消息系统"><span class="toc-text">(5)分布式消息系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-分布式搜索系统"><span class="toc-text">(6)分布式搜索系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-其他很多的技术"><span class="toc-text">(7)其他很多的技术</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>
    </div>
  </section>


            
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
            
              <section class='widget grid'>
  
<header class='pure'>
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class='content pure'>
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="/" href="/"
          
          
          id="home">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="/archives/" href="/archives/"
          
            rel="nofollow"
          
          
          id="archives">
          
            <i class="fas fa-archive fa-fw" aria-hidden="true"></i>
          
          文章归档
        </a></li>
      
        <li><a class="flat-box" title="/about/" href="/about/"
          
            rel="nofollow"
          
          
          id="about">
          
            <i class="fas fa-info-circle fa-fw" aria-hidden="true"></i>
          
          关于小站
        </a></li>
      
    </ul>
  </div>
</section>

            
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
            
              

            
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
            
              
  <section class='widget tagcloud'>
    
<header class='pure'>
  <div><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;Hot Tags</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/tags/"
    title="tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <a href="/tags/Hibernate/" style="font-size: 14px; color: #999">Hibernate</a> <a href="/tags/IT/" style="font-size: 24px; color: #555">IT</a> <a href="/tags/IT-%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-Job-zookeeper/" style="font-size: 14px; color: #999">IT - 技术笔记 - Job - zookeeper</a> <a href="/tags/Java/" style="font-size: 14px; color: #999">Java</a> <a href="/tags/Job/" style="font-size: 24px; color: #555">Job</a> <a href="/tags/Kafka/" style="font-size: 14px; color: #999">Kafka</a> <a href="/tags/Linux/" style="font-size: 14px; color: #999">Linux</a> <a href="/tags/Mybatis/" style="font-size: 14px; color: #999">Mybatis</a> <a href="/tags/Redis/" style="font-size: 14px; color: #999">Redis</a> <a href="/tags/Spring/" style="font-size: 14px; color: #999">Spring</a> <a href="/tags/mysql/" style="font-size: 14px; color: #999">mysql</a> <a href="/tags/zookeeper/" style="font-size: 14px; color: #999">zookeeper</a> <a href="/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" style="font-size: 24px; color: #555">技术笔记</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 14px; color: #999">排序</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 20.67px; color: #6c6c6c">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 14px; color: #999">数据结构</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/" style="font-size: 17.33px; color: #828282">服务端开发</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 14px; color: #999">算法</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 14px; color: #999">网络</a>
    </div>
  </section>


            
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="/atom.xml"
            class="social fas fa-rss flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="mailto:dmlys@live.com"
            class="social fas fa-envelope flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/ChanMango"
            class="social fab fa-github flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://music.163.com/#/user/home?id=118376074"
            class="social fas fa-headphones-alt flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  <br>
  <div><p>Blog content follows the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
  <div>
    Use
    <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a>
    as theme
    
      , 
      total visits
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      times
    
    . 
  </div>
</footer>
<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>




  
  
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>
    <script type="text/javascript">
      $(function(){
        if ('.cover') {
          $('.cover').backstretch(
          ["assets/cover5.jpg"],
          {
            duration: "6000",
            fade: "2500"
          });
        } else {
          $.backstretch(
          ["assets/cover5.jpg"],
          {
            duration: "6000",
            fade: "2500"
          });
        }
      });
    </script>
  











  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.9/js/app.js"></script>


  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.9/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "Copied";
  let COPY_FAILURE = "Copy failed";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>Copy</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  <script>setLoadingBarProgress(100);</script>
</body>
</html>

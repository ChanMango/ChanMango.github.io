<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Java高级核心 | 蜗牛君</title>
  
  <meta name="keywords" content="IT民工,技术干货,避坑指南">
  
  
  <meta name="description" content="这是一篇关于Java的综合知识整理">
  

  

  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css">
  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.9.9/css/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  
  <div class="cover-wrapper">
    <cover class='cover post half'>
      
        
  <h1 class='title'>蜗牛君的NoteBook</h1>


  <div class="m_search">
    <form name="searchform" class="form u-search-form">
      <input type="text" class="input u-search-input" placeholder="" />
      <i class="icon fas fa-search fa-fw"></i>
    </form>
  </div>

<div class='menu navgation'>
  <ul class='h-list'>
    
  </ul>
</div>

      
    </cover>
    <header class="l_header pure">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="pure"></div>
  </div>

	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href='/' >
        
          蜗牛君
        
      </a>
			<div class='menu navgation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="/"
                  
                  
                  id="home">
									<i class='fas fa-grin fa-fw'></i>&nbsp;主页
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/categories/"
                  
                    rel="nofollow"
                  
                  
                  id="categories">
									<i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/tags/"
                  
                    rel="nofollow"
                  
                  
                  id="tags">
									<i class='fas fa-hashtag fa-fw'></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/archives/"
                  
                    rel="nofollow"
                  
                  
                  id="archives">
									<i class='fas fa-archive fa-fw'></i>&nbsp;归档
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="Search" />
						<i class="icon fas fa-search fa-fw"></i>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a class="fas fa-search fa-fw" href='javascript:void(0)'></a></li>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/"
                
                
                id="home">
								<i class='fas fa-clock fa-fw'></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/archives/"
                
                  rel="nofollow"
                
                
                id="archives">
								<i class='fas fa-archive fa-fw'></i>&nbsp;文章归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/projects/"
                
                
                id="projects">
								<i class='fas fa-code-branch fa-fw'></i>&nbsp;开源项目
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/friends/"
                
                  rel="nofollow"
                
                
                id="friends">
								<i class='fas fa-link fa-fw'></i>&nbsp;我的友链
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="https://xaoxuu.com/wiki/material-x/"
                
                  rel="nofollow"
                
                
                id="https:xaoxuu.comwikimaterial-x">
								<i class='fas fa-book fa-fw'></i>&nbsp;主题文档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/"
                
                  rel="nofollow"
                
                
                id="about">
								<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于小站
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      <div class='l_main'>
  

  <article id="post" class="post white-box article-type-post" itemscope itemprop="blogPost">
    


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="/2019/10/20/Java%E9%AB%98%E7%BA%A7/">
        Java高级核心
      </a>
    </h1>
  


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="/" rel="nofollow">
        
          <i class="fas fa-user" aria-hidden="true"></i>
        
        <p>蜗牛君</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-10-20</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/Java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java</p>
    </a>
  </div>


          
        
          
            
  
    <div class="new-meta-item browse busuanzi">
      <a class='notlink'>
        <i class="fas fa-eye" aria-hidden="true"></i>
        <p>
          <span id="busuanzi_value_page_pv">
            <i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i>
          </span>
        </p>
      </a>
    </div>
  


          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


    <section class="article typo">
      <div class="article-entry" itemprop="articleBody">
        <h2 id="队列"><a href="/2019/10/20/Java高级/#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="等待队列（Condition-Queue）"><a href="/2019/10/20/Java高级/#等待队列（Condition-Queue）" class="headerlink" title="等待队列（Condition Queue）"></a>等待队列（Condition Queue）</h3><p> 我们都熟悉wait/notify，它主要是实现线程间协作的，其常用的使用模式如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(T t)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> <span class="keyword">while</span> (isFull())&#123;</span><br><span class="line">  wait();</span><br><span class="line"> &#125;</span><br><span class="line">  produce(t);</span><br><span class="line">  notifyAll();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (isEmpty())&#123;</span><br><span class="line"> wait();</span><br><span class="line">&#125;</span><br><span class="line">T t = consume();</span><br><span class="line">notifyAll();</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当条件满足，原来等待的线程就会立即被唤醒，这就要涉及到等待队列</strong>，等待队列中的是等待某类条件发生的线程。每一个对象都可以作为锁对象，也同时被当作一个等待队列，并具有wait，notify，notifyall方法，另见图：</p>
<img src="/2019/10/20/Java高级//s3mwug4mwy.png" alt="img" style="zoom:67%;">

<p>判断条件总是涉及到一些状态，如集合是否已满，是否为空等等，这些状态变量必须被锁监控，因为线程在等待或者唤醒另一个线程前，需要访问、操作这些与条件相关的状态变量，而加锁可以保证状态的一致性。另外，正如上例所示，<strong>wait方法必须包含在while循环中</strong>，原因有二：</p>
<p>  1、从线程被唤醒到重新获得锁的间隙，其他线程获取了锁并且改变了状态，使得条件重新变为false。</p>
<p>  2、如果<strong>多种条件与一个等待队列关联，必须使用notifyAll</strong>,一个线程可能在条件不满足的情况下被唤醒，这时候需要重新检查条件。</p>
<p>对象的内置锁只有一个内置等待队列与其关联，这样多个唤醒条件不同的线程就必须在同一个等待队列上，唤醒线程时必须使用notifyAll，导致大部分不符合条件的线程将被唤醒并且参与锁竞争，上下文切换频繁，性能下降，当然，notifyAll是一种比较安全保险的做法。上次我们提过还有另一种实现锁的形式，即Lock，与其对应的是Condition，它可以根据不同的条件提供对应的condition，可将上述使用模式改装一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">protected final Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> private final Condition notFull = lock.newCondition();</span><br><span class="line"> private final Condition notEmpty = lock.newCondition();</span><br><span class="line"> public <span class="keyword">void</span> produce(T t) throws InterruptedException &#123;</span><br><span class="line"> lock.lock();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="keyword">while</span> (isFull()) &#123;</span><br><span class="line"> notFull.await();</span><br><span class="line">   &#125;</span><br><span class="line">   produce(t);</span><br><span class="line"> notEmpty.signal();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> public T consume() throws InterruptedException &#123;</span><br><span class="line"> lock.lock();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="keyword">while</span> (isEmpty()) &#123;</span><br><span class="line"> notEmpty.await();</span><br><span class="line">   &#125;</span><br><span class="line">   T t = consume();</span><br><span class="line"> notFull.signal();</span><br><span class="line"> <span class="keyword">return</span> t;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>通过wait/notify实现线程间协作，是需要一定的技巧的，初级的开发人员不一定能正确使用，我们可以使用一些并发工具类，像LinkedBlockingQueue，ConcurrentHashMap，CountDownLatch实现相应的功能</p>
<h3 id="BlockingQueue"><a href="/2019/10/20/Java高级/#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><blockquote>
<p>   在新增的Concurrent包中，BlockingQueue很好的解决了多线程中，如何高效安全“传输”数据的问题 </p>
</blockquote>
<p>​                                                                         <img src="/2019/10/20/Java高级//ygyjw29x7r.jpeg" alt="img"> </p>
<p>常用的队列主要有以下两种：（当然通过不同的实现方式，还可以延伸出很多不同类型的队列，DelayQueue就是其中的一种） 　</p>
<ul>
<li><p>先进先出（FIFO）：先插入的队列的元素也最先出队列，类似于排队的功能。从某种程度上来说这种队列也体现了一种公平性。 　</p>
</li>
<li><p>后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发生的事件。 </p>
<p>​                                                                             <img src="/2019/10/20/Java高级//saznmdd4f0.jpeg" alt="img">  </p>
</li>
</ul>
<p><em>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。</em> </p>
<p><img src="/2019/10/20/Java高级//g0ajbnsdtp-1571457972709.jpeg" alt="img"></p>
<p><em>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒。</em><br>BlockingQueue的核心方法:</p>
<ul>
<li>offer(anObject):表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回false.（本方法不阻塞当前执行方法的线程） 　</li>
<li>put(anObject):把anObject加到BlockingQueue里,如果BlockQueue没有空间,则<strong>调用此方法的线程被阻断</strong>,直到BlockingQueue里面有空间再继续. 获取数据</li>
<li>poll(long timeout, TimeUnit unit)：从BlockingQueue取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。 　</li>
<li>take():取走BlockingQueue里排在首位的对象,若BlockingQueue为空,<strong>阻断进入等待状态</strong>直到BlockingQueue有新的数据被加入;  </li>
</ul>
<h3 id="常见BlockingQueue"><a href="/2019/10/20/Java高级/#常见BlockingQueue" class="headerlink" title="常见BlockingQueue"></a>常见BlockingQueue</h3><p><img src="/2019/10/20/Java高级//evyyu8oakr.jpeg" alt="img"></p>
<ul>
<li><p><strong>1. ArrayBlockingQueue</strong>      基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。 　ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是<strong>共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue</strong>；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。 </p>
</li>
<li><p><strong>2. LinkedBlockingQueue</strong>      基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当<strong>队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列</strong>，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。 作为开发者，我们需要注意的是，如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，<strong>LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了</strong>。 ArrayBlockingQueue和LinkedBlockingQueue是两个最普通也是最常用的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个类足以。</p>
</li>
<li><p><strong>3. DelayQueue</strong>      DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。 使用场景： 　DelayQueue使用场景较少，但都相当巧妙，常见的例子比如使用一个DelayQueue来管理一个超时未响应的连接队列。 </p>
</li>
<li><p><strong>4. PriorityBlockingQueue</strong>      基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。 </p>
</li>
<li><p><strong>5. SynchronousQueue</strong>      一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用<strong>中间经销商的模式会吞吐量高一些（可以批量买卖）</strong>；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。 　声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。公平模式和非公平模式的区别: 　如果采用公平模式：<strong>SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；</strong> 　但<strong>如果是非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者</strong>，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</p>
</li>
</ul>
<h2 id="设计模式"><a href="/2019/10/20/Java高级/#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><blockquote>
<p>常见:  <strong>单例模式、工厂模式、建造模式、观察者模式、适配器模式、代理模式、装饰模式.</strong></p>
</blockquote>
<h3 id="设计模式的六大原则及其含义"><a href="/2019/10/20/Java高级/#设计模式的六大原则及其含义" class="headerlink" title="设计模式的六大原则及其含义:"></a>设计模式的六大原则及其含义:</h3><ol>
<li>单一职责原则：<strong>一个类只负责一个功能领域中的相应职责</strong>，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。主要作用实现代码高内聚，低耦合。</li>
<li>开闭原则：一个软件实体应当<strong>对扩展开放，对修改关闭</strong>。即软件实体应尽量在不修改原有代码的情况下进行扩展。</li>
<li>里氏替换原则：所有引用基类（父类）的地方必须能透明地使用其子类的对象。里氏替换原则是实现开闭原则的方式之一</li>
<li>依赖倒置原则：抽象不应该依赖于细节，<strong>细节应当依赖于抽象</strong>。换言之，要针对接口编程，而不是针对实现编程。</li>
<li>接口隔离原则：<strong>使用多个专门的接口，而不使用单一的总接口</strong>，即客户端不应该依赖那些它不需要的接口。</li>
<li>迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用。</li>
</ol>
<h3 id="常见模式及优缺点："><a href="/2019/10/20/Java高级/#常见模式及优缺点：" class="headerlink" title="常见模式及优缺点："></a><strong>常见模式及优缺点</strong>：</h3><ul>
<li><p>饿汉式：</p>
<p>优点：不用加锁可以确保对象的唯一性，线程安全。</p>
<p>缺点：初始化对象会浪费不必要的资源，未实现延迟加载。</p>
</li>
<li><p>懒汉式：</p>
<p>优点：实现了延时加载。</p>
<p>缺点：线程不安全，想实现线程安全，得加锁（synchronized），这样会浪费一些不必要的资源。</p>
</li>
<li><p>双重检测锁式（</p>
<p>Double Check Lock –DCL）：</p>
<p>优点：资源利用率高，效率高。</p>
<p>缺点：第一次加载稍慢，由于java处理器允许乱序执行，偶尔会失败。</p>
</li>
<li><p>静态内部式：</p>
<p>优点：第一次调用方法时才加载类，不仅保证线程安全还能保证对象的唯一，还延迟了单例的实例化</p>
<p>缺点：无确定</p>
</li>
<li><p>枚举实现单例模式</p>
<p>优点: 线程安全, 任何模式下都是单例的, 包括序列化</p>
<p>推荐使用<strong>静态内部式</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>)  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *当第一次加载Singleton类时并不会初始化SINGLRTON,只有第一次调用getInstance方法的时候才会初始化SINGLETON</span></span><br><span class="line"><span class="comment">    *第一次调用getInstance 方法的时候虚拟机才会加载SingletonHoder类,这种方式不仅能够保证线程安全,也能够保证对象的唯一,</span></span><br><span class="line"><span class="comment">    *还延迟了单例的实例化,所有推荐使用这种方式</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton4 SINGLETON = <span class="keyword">new</span> Singleton4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设计模式在实际场景的应用"><a href="/2019/10/20/Java高级/#设计模式在实际场景的应用" class="headerlink" title="设计模式在实际场景的应用"></a>设计模式在实际场景的应用</h3><p>单例：连接数据库，记录日志</p>
<h3 id="Spring中用到了哪些设计模式"><a href="/2019/10/20/Java高级/#Spring中用到了哪些设计模式" class="headerlink" title="==Spring中用到了哪些设计模式=="></a>==Spring中用到了哪些设计模式==</h3><ol>
<li>工厂模式：spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。</li>
<li>代理模式：Spring的AOP就是代理模式的体现。</li>
<li>观察者模式：常用的地方是Listener的实现，spring中ApplicationListener就是观察者的体现。</li>
<li>策略模式：spring在实例化对象的时候使用到了。</li>
<li>工厂方法：Spring中的FactoryBean就是典型的工厂方法模式。</li>
<li>单例模式: </li>
</ol>
<p>参考：<a href="https://www.cnblogs.com/hwaggLee/p/4510687.html">https://www.cnblogs.com/hwaggLee/p/4510687.html</a></p>
<h3 id="MyBatis中用到了哪些设计模式"><a href="/2019/10/20/Java高级/#MyBatis中用到了哪些设计模式" class="headerlink" title="==MyBatis中用到了哪些设计模式=="></a>==MyBatis中用到了哪些设计模式==</h3><ol>
<li>Builder模式，例如SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder；</li>
<li>工厂模式，例如SqlSessionFactory、ObjectFactory、MapperProxyFactory；</li>
<li>单例模式，例如ErrorContext和LogFactory；</li>
<li>代理模式，Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果；</li>
<li>组合模式，例如SqlNode和各个子类ChooseSqlNode等；</li>
<li>模板方法模式，例如BaseExecutor和SimpleExecutor，还有BaseTypeHandler和所有的子类例如IntegerTypeHandler；</li>
<li>适配器模式，例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现；</li>
<li>装饰者模式，例如Cache包中的cache.decorators子包中等各个装饰者的实现；</li>
<li>迭代器模式，例如迭代器模式PropertyTokenizer；</li>
</ol>
<p>参考：<a href="https://www.cnblogs.com/shuchen007/p/9193179.html">https://www.cnblogs.com/shuchen007/p/9193179.html</a></p>
<h3 id="代理模式-Proxy"><a href="/2019/10/20/Java高级/#代理模式-Proxy" class="headerlink" title="代理模式(Proxy)"></a>代理模式(Proxy)</h3><p><strong>静态代理:</strong> AspectJ</p>
<p><strong>动态代理:</strong></p>
<ul>
<li>cglib(静态)</li>
<li>jdk(动态)</li>
</ul>
<h2 id="类加载器"><a href="/2019/10/20/Java高级/#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><blockquote>
<p>顾名思义，类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。</p>
<p>有三类类加载器:</p>
<ul>
<li>启动类加载器 BootStrap ClassLoader</li>
<li>扩展类加载器 Extension ClassLoader</li>
<li>应用类加载器 Application ClassLoader</li>
</ul>
</blockquote>
<img src="/2019/10/20/Java高级//2095550-c1889cec927a36d0.webp" alt="img" style="zoom:67%;">

<h4 id="ClassLoader"><a href="/2019/10/20/Java高级/#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h4><p>ClassLoader类是一个抽象类，它定义了类加载器的基本方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td>getParent()</td>
<td align="center">返回该类加载器的父类加载器。</td>
</tr>
<tr>
<td>loadClass(String name)</td>
<td align="center">加载名称为 name的类，返回的结果是 java.lang.Class类的实例。</td>
</tr>
<tr>
<td>findClass(String name)</td>
<td align="center">查找名称为 name的类，返回的结果是 java.lang.Class类的实例。</td>
</tr>
<tr>
<td>findLoadedClass(String name)</td>
<td align="center">查找名称为 name的已经被加载过的类，返回的结果是 java.lang.Class类的实例。</td>
</tr>
<tr>
<td>defineClass(String name, byte[] b, int off, int len)</td>
<td align="center"><strong>把字节数组 b中的内容转换成 Java 类</strong>，返回的结果是 java.lang.Class类的实例。这个方法被声明为 final的。</td>
</tr>
</tbody></table>
<h4 id="来看看-loadClass-方法的代码：双亲委托机制"><a href="/2019/10/20/Java高级/#来看看-loadClass-方法的代码：双亲委托机制" class="headerlink" title="来看看 loadClass 方法的代码：双亲委托机制"></a>来看看 loadClass 方法的代码：双亲委托机制</h4><p><strong>自定义类加载器一般只重写findClass方法即可</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)&#123;</span><br><span class="line">    Class c = findLoadedClass(name);<span class="comment">//是否已经加载</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;<span class="comment">//没有加载</span></span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//使用父加载器加载此类</span></span><br><span class="line">            c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果父加载器没有成功加载，则自己尝试加载</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="IO"><a href="/2019/10/20/Java高级/#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="Java的io，nio，bio区别"><a href="/2019/10/20/Java高级/#Java的io，nio，bio区别" class="headerlink" title="Java的io，nio，bio区别"></a>Java的io，nio，bio区别</h3><blockquote>
<p><strong>Java IO</strong>（Java数据流）主要就是Java用来读取和输出数据流</p>
<p><strong>读取纯文本数据优选用字符流，其他使用字节流</strong></p>
</blockquote>
<p><strong>Java中IO主要有两类</strong></p>
<ul>
<li>|——&gt;字节流（读写以字节（8bit）为单位，InputStream和OutputStream为主要代表              </li>
<li>|——&gt;字符流（读写以字符为单位，Reader和Writer为主要代表）</li>
</ul>
<p><strong>BIO, NIO, AIO的区别</strong></p>
<ul>
<li>BIO: 同步并阻塞, 服务器模式为一个连接一个线程, 客户端有连接请求时,就必须开启一个线程进行处理, 会造成很大的线程开销–数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下</li>
<li>NIO: 同步非阻塞,服务器模式为:  一个请求一个线程, 即客户端的请求都会注册到多路复用机,轮询到有io请求时才启动一个线程进行处理.<strong>把一些无效的连接挡在了启动线程之前，减少了这部分资源的浪费</strong> –对于<strong>高负载、高并发</strong>的（网络）应用，应使用 <strong>NIO 的非阻塞模式</strong>来开发</li>
<li>AIO: 一部非阻塞, 一个有效的请求一个线程, 客户端的io请求都是os先完成了在通知服务器应用取启动线程进行处理<strong>将一些暂时可能无效的请求挡在了启动线程之前</strong></li>
</ul>
<h3 id="I-O-模型"><a href="/2019/10/20/Java高级/#I-O-模型" class="headerlink" title="I/O 模型"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=一、io-模型">I/O 模型</a></h3><p>一个输入操作通常包括两个阶段：</p>
<ul>
<li>等待数据准备好(<strong>数据复制到内核缓冲区</strong>)</li>
<li>从内核向进程复制数据</li>
</ul>
<p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p>
<p>Unix 有五种 I/O 模型：</p>
<ul>
<li>阻塞式 I/O (BIO)</li>
<li><strong>非阻塞式 I/O</strong> (NIO)</li>
<li>I/O 复用（select 和 poll）</li>
<li>信号驱动式 I/O（SIGIO）</li>
<li><strong>异步 I/O（AIO）</strong></li>
</ul>
<h4 id="阻塞式-I-O"><a href="/2019/10/20/Java高级/#阻塞式-I-O" class="headerlink" title="阻塞式 I/O"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=阻塞式-io">阻塞式 I/O</a></h4><blockquote>
<p>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。</p>
<p>应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为<strong>其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高</strong>。</p>
</blockquote>
<p>下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen);Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<img src="/2019/10/20/Java高级//1492928416812_4-1570685864033.png" alt="img" style="zoom: 67%;">

<h4 id="非阻塞式-I-O"><a href="/2019/10/20/Java高级/#非阻塞式-I-O" class="headerlink" title="非阻塞式 I/O"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=非阻塞式-io">非阻塞式 I/O</a></h4><blockquote>
<p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是<strong>需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）</strong>。</p>
<p>由于 CPU 要处理更多的系统调用，因此这种模型的 <strong>CPU 利用率比较低-因为要去不断的轮询是否数据准备好</strong>。</p>
</blockquote>
<img src="/2019/10/20/Java高级//1492929000361_5.png" alt="img" style="zoom:67%;">

<p>==<strong>此时数据准备阶段不会阻塞, 而数据复制阶段一样会阻塞</strong>==</p>
<h4 id="I-O-复用"><a href="/2019/10/20/Java高级/#I-O-复用" class="headerlink" title="I/O 复用"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=io-复用">I/O 复用</a></h4><blockquote>
<p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。</p>
<p>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。</p>
<p><strong>I/O复用可以避免频繁创建和销毁线程, 以及切换线程的开销</strong></p>
</blockquote>
<p>如果一个 Web 服务器没有 I/O 复用，那么<strong>每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小</strong>。</p>
<img src="/2019/10/20/Java高级//1492929444818_6.png" alt="img" style="zoom:67%;">

<p><strong>==在数据准备阶段select是阻塞的==</strong></p>
<h4 id="信号驱动-I-O"><a href="/2019/10/20/Java高级/#信号驱动-I-O" class="headerlink" title="信号驱动 I/O"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=信号驱动-io">信号驱动 I/O</a></h4><blockquote>
<p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p>
<p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 <strong>CPU 利用率更高</strong>-数据准备阶段不阻塞。</p>
</blockquote>
<img src="/2019/10/20/Java高级//1492929553651_7.png" alt="img" style="zoom:67%;">



<h4 id="异步-I-O-AIO"><a href="/2019/10/20/Java高级/#异步-I-O-AIO" class="headerlink" title="异步 I/O (AIO)"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=异步-io">异步 I/O</a> (AIO)</h4><blockquote>
<p>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p>
<p>异步 I/O 与信号驱动 I/O 的区别在于，<strong>异步 I/O 的信号是通知应用进程 I/O 完成</strong>，而<strong>信号驱动 I/O 的信号是通知应用进程可以开始 I/O</strong>。</p>
</blockquote>
<img src="/2019/10/20/Java高级//1492930243286_8.png" alt="img" style="zoom:67%;">



<h4 id="五大-I-O-模型比较"><a href="/2019/10/20/Java高级/#五大-I-O-模型比较" class="headerlink" title="五大 I/O 模型比较"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=五大-io-模型比较">五大 I/O 模型比较</a></h4><ul>
<li>同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。</li>
<li>异步 I/O：<strong>第二阶段应用进程不会阻塞</strong>。</li>
</ul>
<p>同步 I/O 包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O ，它们的主要区别在第一个阶段。</p>
<p>非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。</p>
<img src="/2019/10/20/Java高级//1492928105791_3.png" alt="img" style="zoom:67%;">



<h4 id="I-O-复用-详细讲解"><a href="/2019/10/20/Java高级/#I-O-复用-详细讲解" class="headerlink" title="I/O 复用 详细讲解"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=二、io-复用">I/O 复用 详细讲解</a></h4><p>select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。</p>
<h5 id="select"><a href="/2019/10/20/Java高级/#select" class="headerlink" title="select"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=select">select</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。</p>
<ul>
<li>fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听少于 FD_SETSIZE 数量的描述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。</li>
<li>timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。</li>
<li>成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。</li>
</ul>
<h5 id="poll"><a href="/2019/10/20/Java高级/#poll" class="headerlink" title="poll"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=poll">poll</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。</p>
<p>poll 中的描述符是 pollfd 类型的数组，pollfd 的定义如下：</p>
<h5 id="比较"><a href="/2019/10/20/Java高级/#比较" class="headerlink" title="比较"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=比较">比较</a></h5><h6 id="1-功能"><a href="/2019/10/20/Java高级/#1-功能" class="headerlink" title="1. 功能"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_1-功能">1. 功能</a></h6><p>select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。</p>
<ul>
<li>select 会修改描述符，而 poll 不会；</li>
<li>select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；</li>
<li>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。</li>
<li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。</li>
</ul>
<h6 id="2-速度"><a href="/2019/10/20/Java高级/#2-速度" class="headerlink" title="2. 速度"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_2-速度">2. 速度</a></h6><p>select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。</p>
<h6 id="3-可移植性"><a href="/2019/10/20/Java高级/#3-可移植性" class="headerlink" title="3. 可移植性"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_3-可移植性">3. 可移植性</a></h6><p>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</p>
<h5 id="epoll"><a href="/2019/10/20/Java高级/#epoll" class="headerlink" title="epoll"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=epoll">epoll</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。</p>
<p>从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。</p>
<p>epoll 仅适用于 Linux OS。</p>
<p>epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。</p>
<p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。</p>
<h6 id="工作模式"><a href="/2019/10/20/Java高级/#工作模式" class="headerlink" title="工作模式"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=工作模式">工作模式</a></h6><p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。</p>
<p><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_1-lt-模式">1. LT 模式</a></p>
<p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p>
<p><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_2-et-模式">2. ET 模式</a></p>
<p>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。</p>
<p>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h4 id="应用场景"><a href="/2019/10/20/Java高级/#应用场景" class="headerlink" title="应用场景"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=应用场景">应用场景</a></h4><p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p>
<h5 id="1-select-应用场景"><a href="/2019/10/20/Java高级/#1-select-应用场景" class="headerlink" title="1. select 应用场景"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_1-select-应用场景">1. select 应用场景</a></h5><p>select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。</p>
<p>select 可移植性更好，几乎被所有主流平台所支持。</p>
<h5 id="2-poll-应用场景"><a href="/2019/10/20/Java高级/#2-poll-应用场景" class="headerlink" title="2. poll 应用场景"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_2-poll-应用场景">2. poll 应用场景</a></h5><p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p>
<h5 id="3-epoll-应用场景"><a href="/2019/10/20/Java高级/#3-epoll-应用场景" class="headerlink" title="3. epoll 应用场景"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=_3-epoll-应用场景">3. epoll 应用场景</a></h5><p>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。</p>
<p>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。</p>
<p>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</p>
<ul>
<li>I/O 复用（select 和 poll）</li>
<li>信号驱动式 I/O（SIGIO）</li>
<li><strong>异步 I/O（AIO）</strong></li>
</ul>
<h2 id="多线程"><a href="/2019/10/20/Java高级/#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="进程和线程区别"><a href="/2019/10/20/Java高级/#进程和线程区别" class="headerlink" title="进程和线程区别"></a>进程和线程区别</h3><ul>
<li>进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例</li>
<li>线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量,是一个独立的执行单元<strong>主要用于解决程序执行的效率</strong></li>
</ul>
<h3 id="守护线程-amp-非守护线程"><a href="/2019/10/20/Java高级/#守护线程-amp-非守护线程" class="headerlink" title="守护线程&amp;非守护线程"></a>守护线程&amp;非守护线程</h3><blockquote>
<p>GC线程属于守护线程, 和主线程同生共死</p>
</blockquote>
<p>用户线程也叫非守护线程, 用户自己创建的线程, 如果主线程停止掉,不会影响用户线程. 用户线程非守护线程</p>
<h3 id="线程的状态转换"><a href="/2019/10/20/Java高级/#线程的状态转换" class="headerlink" title="线程的状态转换"></a>线程的状态转换</h3> <img src="/2019/10/20/Java高级//1294022-20171206070245644-1496567738.png" alt="img" style="zoom:67%;"> 

<h3 id="线程安全"><a href="/2019/10/20/Java高级/#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p><strong>coout++</strong></p>
<p>count++ 这行代码实际上需要执行三个指令：</p>
<p>getfield：从内存中获取变量 count 的值<br>iadd：将 count 加 1<br>putfield：将加 1 后的结果赋值给 count 变量<br><strong>这也就是线程不安全的原因所在，因为 count++ 操作不具备原子性。</strong></p>
<p>原子性操作指的是不可被中断的一个或一系列操作。下图描述了为什么非原子操作造成了这里的线程不安全问题</p>
 <img src="/2019/10/20/Java高级//20190704114751129.png" alt="在这里插入图片描述" style="zoom: 50%;"> 

<p>假设有两个线程去执行 add 操作，此时 count 是 0，那么存在上图中的这种可能，在线程 A 执行这三步的过程中 cpu 时间片耗尽线程 B 被调度，此时由于内存中 count 的值仍为 0（因为线程 A 的操作结果还未刷新到内存中），所以线程 B 仍是在 0 的基础上执行自增，所以导致最终内存中的 count 是 1，而不是 2.</p>
<h3 id="为什么要用线程池"><a href="/2019/10/20/Java高级/#为什么要用线程池" class="headerlink" title="为什么要用线程池?"></a><strong>为什么要用线程池?</strong></h3><blockquote>
<p>线程池作用就是限制系统中执行线程的数量。根据系统的环境情况, 可以手动或者自动的设置线程数量, 避免浪费系统资源, 造成系统拥挤, 当一个新任务需要运行时，如果线程池 中有等待的工作线程，就可以开始运行了；否则进入等待队列。 </p>
</blockquote>
<ol>
<li><p><strong>减少</strong>了<strong>创建和销毁线程的次数</strong>, 每个<strong>工作线程</strong>都可以被<strong>重复利用</strong>, 可执行多个任务</p>
</li>
<li><p>可以根据系统的承受能力, <u>调整线程池中工作线程的数目, 防止因为消耗过多的内存</u>, (每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。 </p>
<p>Java里边线程池的顶级接口时Executor, 但是严格意义上将Executor并不是一个线程池, 而是一个执行工具,真正的线程池接口时<strong>ExecutorService</strong></p>
</li>
</ol>
<h4 id="线程中重要的几个类"><a href="/2019/10/20/Java高级/#线程中重要的几个类" class="headerlink" title="线程中重要的几个类"></a>线程中重要的几个类</h4><ul>
<li><p><strong>ExecutorService</strong> </p>
<p>真正的线程池接口。</p>
</li>
<li><p><strong>ScheduledExecutorService</strong><br>能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。</p>
</li>
<li><p><strong>ThreadPoolExecutor</strong><br>ExecutorService的默认实现。</p>
</li>
<li><p><strong>ScheduledThreadPoolExecutor</strong><br>继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。</p>
</li>
</ul>
<h4 id="new-Thread的弊端"><a href="/2019/10/20/Java高级/#new-Thread的弊端" class="headerlink" title="new Thread的弊端"></a>new Thread的弊端</h4><ol>
<li>每次new Thread新建对象性能差。 </li>
<li>线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。 </li>
<li>缺乏更多功能，如定时执行、定期执行、线程中断。 </li>
</ol>
<h4 id="Java提供的四种线程池的好处在于："><a href="/2019/10/20/Java高级/#Java提供的四种线程池的好处在于：" class="headerlink" title="Java提供的四种线程池的好处在于："></a>Java提供的四种线程池的好处在于：</h4><ol>
<li>重用存在的线程，减少对象创建、消亡的开销，性能佳。 </li>
<li>可有效<strong>控制最大并发线程数</strong>，提高系统资源的使用率，同时<strong>避免过多资源竞争</strong>，避免<strong>堵塞</strong>。 </li>
<li>提供<u>定时执行、定期执行、单线程、并发数控制</u>等功能。</li>
</ol>
<h3 id="四种线程池"><a href="/2019/10/20/Java高级/#四种线程池" class="headerlink" title="四种线程池"></a><strong>四种线程池</strong></h3><p>Java通过Executors提供<strong>四种线程池</strong>,分别为:</p>
<ol>
<li><p><strong>newCachedThreadPool</strong></p>
<p>创建一个可缓存的线程池, 如果线程池长度超过处理需要, 可以灵活回收空闲线程, 若无可回收,则新建线程</p>
<p>==适应场景: 创建一个可以无限扩大的线程池，适用于服务器负载较轻，执行很多短期异步任务。== </p>
</li>
<li><p><strong>newFixedThreadPool</strong></p>
<p>创建一个定长线程池,可控制线程最大并发数, 采用无界的阻塞队列，所以实际线程数量永远不会变化,超出的线程会在队列中等待</p>
<p>适应场景:适用于可以预测线程数量的业务中，或者服务器负载较重，对当前线程数量进行限制。</p>
</li>
<li><p><strong>newScheduledThreadPool</strong></p>
<p>创建一个定长线程池, 至此定时及周期性任务执行</p>
<p>==适应场景: 适用于需要多个后台线程执行周期任务的场景。==</p>
</li>
<li><p><strong>newSingleThreadExecutor</strong></p>
<p>创建一个单线程化的线程池, 它只会用唯一的工作线程来执行任务, <u>保证所有任务按照指定顺序(FIFO, LIFO,优先级)执行</u></p>
<p>==适应场景: 适用于需要保证顺序执行各个任务，并且在任意时间点，不会有多个线程是活动的场景。== </p>
</li>
</ol>
<h4 id="submit-和execute-的以及shutdown-和shutdownNow-的区别"><a href="/2019/10/20/Java高级/#submit-和execute-的以及shutdown-和shutdownNow-的区别" class="headerlink" title="submit()和execute()的以及shutdown()和shutdownNow()的区别"></a>submit()和execute()的以及shutdown()和shutdownNow()的区别</h4><ul>
<li>submit()，提交一个线程任务，可以<strong>接受回调函数的返回值吗</strong>，适用于需要处理返回着或者异常的业务场景 </li>
<li>execute()，执行一个任务，<strong>没有返回值</strong> </li>
<li>shutdown()，表示<strong>不再接受新任务</strong>，但<strong>不会强行终止已经提交</strong>或者<strong>正在执行</strong>中的<strong>任务</strong> </li>
<li>shutdownNow()，对于<strong>尚未执行的任务全部取消</strong>，<strong>正在执行</strong>的任务全部发出interrupt()，<strong>停止执行</strong> </li>
</ul>
<h4 id="RejectedExecutionHandler-线程池四种拒绝任务策略"><a href="/2019/10/20/Java高级/#RejectedExecutionHandler-线程池四种拒绝任务策略" class="headerlink" title="RejectedExecutionHandler 线程池四种拒绝任务策略"></a>RejectedExecutionHandler 线程池四种拒绝任务策略</h4><blockquote>
<p>线程池有一个任务队列，用于缓存所有待处理的任务，正在处理的任务将从任务队列中移除。因此在任务队列长度有限的情况下就会出现新任务的拒绝处理问题，需要有一种策略来处理应该加入任务队列却因为队列已满无法加入的情况。另外在线程池关闭的时候也需要对任务加入队列操作进行额外的协调处理。</p>
</blockquote>
<p><strong>RejectedExecutionHandler提供了四种方式来处理任务拒绝策略</strong>:  -&gt;==这四种策略是独立无关的==</p>
<ul>
<li>1、直接丢弃（DiscardPolicy）</li>
<li>2、丢弃队列中最老的任务(DiscardOldestPolicy)。</li>
<li>3、抛异常(AbortPolicy)</li>
<li>4、将任务分给调用线程来执行(CallerRunsPolicy)。</li>
</ul>
<h4 id="Runnable-Callable-Future和-FutureTask"><a href="/2019/10/20/Java高级/#Runnable-Callable-Future和-FutureTask" class="headerlink" title="Runnable, Callable, Future和 FutureTask"></a>Runnable, Callable, Future和 FutureTask</h4><blockquote>
<p>直接继承Thread, 和Runnable都不能返回执行结果, 就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。</p>
</blockquote>
<h5 id="Callable与Runnable"><a href="/2019/10/20/Java高级/#Callable与Runnable" class="headerlink" title="Callable与Runnable"></a>Callable与Runnable</h5><p>Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()：一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明了若干个submit方法的重载版本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<h5 id="Future"><a href="/2019/10/20/Java高级/#Future" class="headerlink" title="Future"></a>Future</h5><blockquote>
<p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。Future类位于java.util.concurrent包下，它是一个接口</p>
</blockquote>
<p>Future提供了三种功能：</p>
<p>　　1）判断任务是否完成；</p>
<p>　　2）能够中断任务；</p>
<p>　　3）能够获取任务执行结果。</p>
<p>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。</p>
<h5 id="FutureTask"><a href="/2019/10/20/Java高级/#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h5><blockquote>
<p>可以看出RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="锁"><a href="/2019/10/20/Java高级/#锁" class="headerlink" title="锁"></a>锁</h2><blockquote>
<p>常见的锁有synchronized、volatile、偏向锁、轻量级锁、重量级锁</p>
</blockquote>
<h3 id="死锁的原因"><a href="/2019/10/20/Java高级/#死锁的原因" class="headerlink" title="死锁的原因"></a>死锁的原因</h3><ol>
<li>互斥性: 某一段时间内, 某一资源只能一个线程使用</li>
<li>请求保持: A申请了一部分资源不足以运行,需要额外的其他资源,但又申请不到, 而其他线程又拿不到A保持的那份资源</li>
<li>不可剥夺: 进程未使用完之前,资源不可剥夺</li>
<li>循环等待: 进程资源形成环型链, 导致任何一个线程都拿不到运行所需的全部资源</li>
</ol>
<h3 id="CAS"><a href="/2019/10/20/Java高级/#CAS" class="headerlink" title="CAS"></a>CAS</h3><blockquote>
<p>CAS(Compare and Swap):  <strong>它的作用是将指定内存地址的内容与所给的某个值相比，如果相等，则将其内容替换为指令中提供的新值，如果不相等，则更新失败。这一比较并交换的操作是原子的，不可以被中断**</strong></p>
<p>==CAS是通过硬件命令保证了原子性==</p>
<p>（1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</p>
<p>（2）一个线程持有锁会导致其它所有需要此锁的线程挂起。</p>
<p>（3）如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</p>
<p>volatile是不错的机制，但是volatile不能保证原子性。因此对于同步最终还是要回到锁机制上来。独占锁是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁用到的机制就是CAS，Compare and Swap。</p>
</blockquote>
<h4 id="CAS导致的问题"><a href="/2019/10/20/Java高级/#CAS导致的问题" class="headerlink" title="CAS导致的问题"></a>CAS导致的问题</h4><ol>
<li><p><strong>ABA问题</strong></p>
<p>大多数情况下乐观锁的实现都会通过<strong>引入一个版本号标记</strong>这个对象，每次修改版本号都会变话，比如使用<strong>时间戳作为版本号</strong>，这样就可以很好的解决ABA问题</p>
<p>在JDK中提供了<strong>AtomicStampedReference</strong>类来解决这个问题，思路是一样的。这个类也维护了一个int类型的标记stamp，<strong>每次更新数据的时候顺带更新一下stamp</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 带有时间戳的原子类，不存在ABA问题，第二个参数就是默认时间戳，这里指定为0</span></span><br><span class="line">AtomicStampedReference&lt;Integer&gt; a2 = <span class="keyword">new</span> AtomicStampedReference&lt;Integer&gt;(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//可以看到使用AtomicStampedReference进行compareAndSet的时候，除了要验证数据，还要验证时间戳。</span></span><br><span class="line"> a2.compareAndSet(<span class="number">10</span>, <span class="number">11</span>, stamp, stamp + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><em>AtomicInteger的CAS原理</em></p>
<blockquote>
<p>​      通过查看AtomicInteger的源码可知， 通过申明一个<strong>volatile</strong> （内存锁定，同一时刻只有一个线程可以修改内存值）类型的变量，再加上unsafe.<strong>compareAndSwapInt</strong>的方法，来<strong>保证实现线程同步</strong>的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123; </span><br><span class="line">                    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update); </span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环时间长开销大</p>
<p>  <strong>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销</strong>。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。 </p>
</li>
<li><p>只能保证一个共享变量的原子操作</p>
<p>当<strong>对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时</strong>，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下<em>ij=2a，然后用CAS来操作ij</em>。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。 </p>
</li>
</ol>
<h3 id="synchronized、volatile的区别"><a href="/2019/10/20/Java高级/#synchronized、volatile的区别" class="headerlink" title="synchronized、volatile的区别"></a>synchronized、volatile的区别</h3><ul>
<li><strong>相同点</strong>：都保证了可见性</li>
<li><strong>不同点</strong> ： ==volatile不能保证原子性==，但是==synchronized能保证原子性且会发生阻塞==（在线程状态转换中详说），开销更大。</li>
</ul>
<h4 id="Volatile"><a href="/2019/10/20/Java高级/#Volatile" class="headerlink" title="Volatile"></a>Volatile</h4><blockquote>
<p><strong>volatile可以看做是一种synchronized的轻量级锁</strong>，他能够保证并发时，被它修饰的共享变量的可见性，当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p> volatile可以解决指令重排，它使用的是内存屏障进行解决的，所谓的内存屏障是一个cpu命令，它有两个作用保证特定的执行顺序，保证可见性，通过在volatile 指令前后增加内存屏障从而解决指令重排问题。 </p>
</blockquote>
<p><strong>实现原理:</strong></p>
<p>被volatile修饰的共享变量在进行写操作的时候</p>
<ul>
<li>1、将当前处理器缓存行的数据写回到系统内存。</li>
<li>2、这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li>
</ul>
<p><strong>使用场景:</strong></p>
<ul>
<li>1.访问变量不需要加锁（加锁的话使用volatile就没必要了）</li>
<li>2、对变量的写操作不依赖于当前值(因为他不能保证原子性)</li>
<li>3.该变量没有包含在具有其他变量的不变式中。</li>
</ul>
<p>一般我们会用来修饰状态标志；读写锁（读&gt;&gt;写，对写加锁，读不加锁）；DCL的单例模式中；volatile bean（例如放入HTTPSession中的对象）</p>
<h4 id="synchronized"><a href="/2019/10/20/Java高级/#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><blockquote>
<p>synchronized是并发编程中接触的最基本的同步工具，是一种<strong>重量级锁,也是 悲观锁</strong>，也是java内置的<strong>同步机制</strong>，首先我们知道synchronized提供了<strong>互斥性的</strong>语义和<strong>可见性</strong>，那么我们可以通过使用它来保证并发的安全。</p>
</blockquote>
<p><strong>synchronized三种用法</strong></p>
<ul>
<li><p>用于类上: </p>
<p>当使用synchronized修饰<strong>类静态方法</strong>时，那么当前<strong>加锁的级别就是类</strong>，当多个线程并发访问该类（所有实例对象）的同步方法以及同步代码块时，<strong>会进行同步</strong></p>
</li>
<li><p>用于代码块:</p>
<p>当使用synchronized修饰代码块时，那么当前<strong>加锁的</strong>级别就<strong>是synchronized（X）中配置的x对象实例</strong>，当多个线程并发访问该对象的同步方法、同步代码块以及当前的代码块时，会进行同步。</p>
<p>==使用同步代码块时要注意的是不要使用String类型对象，因为String常量池的存在，所以很容易导致出问题。==</p>
</li>
</ul>
<h3 id="Synchronized和CAS区别"><a href="/2019/10/20/Java高级/#Synchronized和CAS区别" class="headerlink" title="Synchronized和CAS区别"></a>Synchronized和CAS区别</h3><ul>
<li><strong>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则返回V。</strong>这是一种<strong>乐观锁的思路</strong>，它相信在它修改之前，没有其它线程去修改它；</li>
<li>而<strong>Synchronized是一种悲观锁</strong>，它认为在它修改之前，一定会有其它线程去修改它，悲观锁效率很低。下面来看一下AtomicInteger是如何利用CAS实现原子性操作的。</li>
</ul>
<h3 id="ReentrantLock"><a href="/2019/10/20/Java高级/#ReentrantLock" class="headerlink" title="ReentrantLock"></a><a href="https://blog.csdn.net/yanyan19880509/article/details/52345422">ReentrantLock</a></h3><blockquote>
<p>ReentrantLock实现了Lock接口, 支持两种获取锁的方式，一种是公平模型，一种是非公平模型。</p>
</blockquote>
<p><strong>公平锁模型：</strong></p>
<p>初始化时， state=0，表示无人抢占了打水权。这时候，村民A来打水(A线程请求锁)，占了打水权，把state+1，如下所示：</p>
 <img src="/2019/10/20/Java高级//20160828140603433.jpg" alt="线程A获取锁" style="zoom:50%;"> 

<p>线程A取得了锁，把 state原子性+1,这时候state被改为1，A线程继续执行其他任务，然后来了村民B也想打水（线程B请求锁），线程B无法获取锁，生成节点进行排队，如下图所示：</p>
 <img src="/2019/10/20/Java高级//20160828140648840.jpg" alt="线程B等待" style="zoom:50%;"> 

<p>初始化的时候，会生成一个空的头节点，然后才是B线程节点，这时候，如果线程A又请求锁，是否需要排队？答案当然是否定的，否则就直接死锁了。当A再次请求锁，就相当于是打水期间，同一家人也来打水了，是有特权的，这时候的状态如下图所示：</p>
 <img src="/2019/10/20/Java高级//20160828140726734.jpg" alt="可重入锁获取" style="zoom:50%;"> 

<p>到了这里，相信大家应该明白了什么是可重入锁了吧。就是一个线程在获取了锁之后，再次去获取了同一个锁，这时候仅仅是把状态值进行累加。如果线程A释放了一次锁，就成这样了：</p>
<img src="/2019/10/20/Java高级//20160828140803281.jpg" alt="线程A释放一次锁" style="zoom:50%;"> 

<p>仅仅是把状态值减了，只有线程A把此锁全部释放了，状态值减到0了，其他线程才有机会获取锁。当A把锁完全释放后，state恢复为0，然后会通知队列唤醒B线程节点，使B可以再次竞争锁。当然，如果B线程后面还有C线程，C线程继续休眠，除非B执行完了，通知了C线程。注意，当一个线程节点被唤醒然后取得了锁，对应节点会从队列中删除。</p>
<p><strong>非公平锁模型</strong></p>
<p>如果你已经明白了前面讲的公平锁模型，那么非公平锁模型也就非常容易理解了。当线程A执行完之后，要唤醒线程B是需要时间的，而且线程B醒来后还要再次竞争锁，所以如果在切换过程当中，来了一个线程C，那么线程C是有可能获取到锁的，如果C获取到了锁，B就只能继续乖乖休眠了。</p>
<h3 id="偏向锁-jvm内部"><a href="/2019/10/20/Java高级/#偏向锁-jvm内部" class="headerlink" title="偏向锁(jvm内部)"></a>偏向锁(jvm内部)</h3><ul>
<li>偏向锁（顾名思义，它会<strong>偏向于第一个访问锁的线程</strong>，如果在运行过程中，同步锁<strong>只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的</strong>，这种情况下，就会<strong>给线程加一个偏向锁</strong>）</li>
<li>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</li>
</ul>
<h3 id="轻量级锁-jvm"><a href="/2019/10/20/Java高级/#轻量级锁-jvm" class="headerlink" title="轻量级锁(jvm)"></a>轻量级锁(jvm)</h3><ul>
<li>轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁；</li>
<li>如果说<strong>轻量级锁</strong>是在<strong>无竞争的情况下使用CAS操作去消除同步使用的互斥量</strong>， 那偏向锁就是在无竞争的情况下把整个同步都消除掉， 连CAS操作都不做了。</li>
</ul>
<h3 id="自旋锁-jvm"><a href="/2019/10/20/Java高级/#自旋锁-jvm" class="headerlink" title="自旋锁(jvm)"></a>自旋锁(jvm)</h3><p>自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们<strong>只需要等一等</strong>（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就<strong>避免用户线程和内核的切换的消耗</strong></p>
<h3 id="jvm内部对锁的操作"><a href="/2019/10/20/Java高级/#jvm内部对锁的操作" class="headerlink" title="jvm内部对锁的操作"></a>jvm内部对锁的操作</h3><p>如果已经存在偏向锁了，则会尝试获取轻量级锁，如果以上两种都失败，则启用自旋锁，如果自旋也没有获取到锁，则使用重量级锁，没有获取到锁的线程阻塞挂起，直到持有锁的线程执行完同步块唤醒他们；</p>
<p><strong>偏向锁是在无锁争用的情况下使用的</strong>，也就是同步开在当前线程没有执行完之前，没有其它线程会执行该同步快，一旦有了第二个线程的争用，偏向锁就会升级为轻量级锁，一点有两个以上线程争用，就会升级为重量级锁；如果线程争用激烈，那么应该禁用偏向锁。</p>
<h3 id="synchronized实现，lock实现，有何区别"><a href="/2019/10/20/Java高级/#synchronized实现，lock实现，有何区别" class="headerlink" title="synchronized实现，lock实现，有何区别"></a>synchronized实现，lock实现，有何区别</h3><img src="/2019/10/20/Java高级//20180904143958577.png" alt="è¿éåå¾çæè¿°" style="zoom: 67%;">

<h2 id="JUC"><a href="/2019/10/20/Java高级/#JUC" class="headerlink" title="JUC"></a>JUC</h2><blockquote>
<p>Unsafe类是在sun.misc包下，不属于Java标准。但是很多Java的基础类库，包括一些被广泛使用的高性能开发库都是基于Unsafe类开发的，比如Netty、Cassandra、Hadoop、Kafka等。Unsafe类在提升Java运行效率，增强Java语言底层操作能力方面起了很大的作用。</p>
<p>Unsafe类使Java拥有了像C语言的指针一样操作内存空间的能力，<strong>同时也带来了指针的问题</strong>。过度的使用Unsafe类会使得出错的几率变大，因此Java官方并不建议使用的，官方文档也几乎没有。<br>通常我们最好也不要使用Unsafe类，除非有明确的目的，并且也要对它有深入的了解才行。</p>
</blockquote>
<h3 id="J-U-C-AQS"><a href="/2019/10/20/Java高级/#J-U-C-AQS" class="headerlink" title="J.U.C - AQS"></a>J.U.C - AQS</h3><p>java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。</p>
<h3 id="CountDownLatch"><a href="/2019/10/20/Java高级/#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><blockquote>
<p>用来控制一个或者多个线程等待多个线程。</p>
<p>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</p>
</blockquote>
<img src="/2019/10/20/Java高级//ba078291-791e-4378-b6d1-ece76c2f0b14.png" alt="img" style="zoom: 67%;">



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownLatchExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">"run.."</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();<span class="comment">//当前线程需要等待Countdownlatch值为0才会苏醒继续执行</span></span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CyclicBarrier"><a href="/2019/10/20/Java高级/#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><blockquote>
<p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p>
<p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p>
</blockquote>
<p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p>
<p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2019/10/20/Java高级//f71af66b-0d54-4399-a44b-f47b58321984.png" alt="img" style="zoom:67%;">



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">"before.."</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">"after.."</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Semaphore"><a href="/2019/10/20/Java高级/#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><blockquote>
<p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p>
</blockquote>
<p>以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> clientCount = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalRequestCount = <span class="number">10</span>;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(clientCount);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.print(semaphore.availablePermits() + <span class="string">" "</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2 1 2 2 2 2 2 1 2 2</span></span><br></pre></td></tr></table></figure>

<h3 id="基本类型原子类"><a href="/2019/10/20/Java高级/#基本类型原子类" class="headerlink" title="基本类型原子类"></a>基本类型原子类</h3><p>concurrent 包中提供了Java基本类型的原子操作封装类—–只要类名包含了Atomic关键字都是用于迸发的类型的封装</p>
<p>如: AtomicInteger, AtomicLong, AtomicIntegerArray, AtomicBoolean, AtomicReference, … 等等</p>
<p><strong>以AtomicInteger为例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 其中getIntVolatile和compareAndSwapInt都是native方法</span></span><br><span class="line"><span class="comment"> * getIntVolatile是获取当前的期望值</span></span><br><span class="line"><span class="comment"> * compareAndSwapInt就是我们平时说的CAS(compare and swap)，通过比较如果内存区的值没有改变，那么就用新值直接给该内存区赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong, <span class="keyword">int</span> paramInt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    i = getIntVolatile(paramObject, paramLong);</span><br><span class="line">  &#125; <span class="keyword">while</span> (!compareAndSwapInt(paramObject, paramLong, i, i + paramInt));</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>incrementAndGet</code>是将自增后的值返回，还有一个方法<code>getAndIncrement</code>是将自增前的值返回，分别对应<code>++i</code>和<code>i++</code>操作。同样的<code>decrementAndGe</code>t和<code>getAndDecrement</code>则对<code>--i</code>和<code>i--</code>操作。</p>
<h3 id="并发容器"><a href="/2019/10/20/Java高级/#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><blockquote>
<p>哈希表非常高效，复杂度为O(1)的数据结构，在Java开发中，我们最常见到最频繁使用的就是HashMap和HashTable，但是在线程竞争激烈的并发场景中使用都不够合理,会导致线程安全问题</p>
</blockquote>
<h4 id="HashMap"><a href="/2019/10/20/Java高级/#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ol>
<li><p><strong>关于位运算</strong> </p>
<p>关于位运算,左移一位就是×2倍的值,  位运算之高效，如下文在本来可以求模运算的时候，也换用位运算提高运算速度 </p>
</li>
<li><p><strong>为何要用2的幂次作为其容量</strong> </p>
<p>为了追求速度与效率，计算key的bucket进行hash计算的时候把取模运算转换为位运算，而当容量一定是2^n时：</p>
<p><strong>h &amp; (length - 1) 等价与 h % length</strong>，但他们是等价（效果）不等效（效率）的，其效果是计算h与length的模</p>
</li>
<li><p><strong>负载因子默认常量：</strong></p>
<p>static final floatDEFAULT_LOAD_FACTOR=0.75f;</p>
</li>
<li><p><strong>hash运算</strong> (为什么长度要是2的原因)</p>
<p>左边两组是数组长度为16（2的4次方），右边两组是数组长度为15。两组的hashcode均为8和9，但是很明显，当它们和1110“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到同一个链表上，那么查询的时候就需要遍历这个链表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hashcode的值会与14（1110）进行“与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！ </p>
 <img src="/2019/10/20/Java高级//4b3732d6-fb5f-369b-b50d-e8b8325c69d4.jpg" alt="点击查看原始大小图片" style="zoom:67%;"> 
</li>
<li><p><strong>hashmap什么时候进行扩容呢？</strong></p>
<p><strong>当hashmap中的元素个数超过数组大小loadFactor时</strong>，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过160.75=12的时候，就把数组的大小扩展为2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能.</p>
</li>
</ol>
<p>HashMap是<strong>线程不安全</strong></p>
<ul>
<li>扩容时可能造成(因为采用了倒插法导致了死循环链表,所以线程不安全-&gt; <strong>1.8采用了顺插法解决了这个问题)</strong></li>
<li>结果覆盖问题(多线程环境下,在同一个桶内插入数据,会拿到头节点,若A对头节点修改值后,b不知道又修改则覆盖了原值)</li>
</ul>
<h4 id="HashTable"><a href="/2019/10/20/Java高级/#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><p>HashTable和HashMap的实现原理几乎一样，差别无非是<strong>1.HashTable不允许key和value为null；2.HashTable是线程安全的。</strong>但是HashTable线程安全的策略实现代价却太大了，简单粗暴，get/put所有相关操作都是synchronized的，这相当于给整个哈希表加了一把<strong>大锁</strong>，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作<strong>串行化</strong>，在==竞争激烈的并发场景中性能就会非常差==。</p>
<img src="/2019/10/20/Java高级//1024555-20170514173954488-1353945142-1566995384603.png" alt="img" style="zoom:67%;">

<p>HashTable性能差主要是由于所有操作需要竞争同一把锁，而如果容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。这就是ConcurrentHashMap所采用的”<strong>分段锁</strong>“思想。</p>
<img src="/2019/10/20/Java高级//1024555-20170514174100832-1891630860.png" alt="img" style="zoom:67%;">

<ul>
<li><p>put的主要逻辑也就两步：</p>
<p><strong>put方法是要加锁的</strong>,  　若c超出阈值threshold，需要扩容并rehash。扩容后的容量是当前容量的2倍。这样可以最大程度避免之前散列好的entry重新散列，具体在另一篇文章中有详细分析，不赘述。扩容并rehash的这个过程是比较消耗资源的。</p>
<ul>
<li>*<em>1.定位segment并确保定位的Segment已初始化 *</em></li>
<li><strong>2.调用Segment的put方法。</strong></li>
</ul>
</li>
<li><p><strong>get方法</strong> 先定位Segment，再定位HashEntry</p>
</li>
<li><p><strong>无需加锁，由于其中涉及到的共享变量都使用volatile修饰，volatile可以保证内存可见性，所以不会读取到过期数据。</strong></p>
</li>
</ul>
<h4 id="Vector"><a href="/2019/10/20/Java高级/#Vector" class="headerlink" title="Vector"></a>Vector</h4><h5 id="1-同步-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-1-同步"><a href="/2019/10/20/Java高级/#1-同步-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-1-同步" class="headerlink" title="[1. 同步](https://cyc2018.github.io/CS-Notes/#/notes/Java 容器?id=_1-同步)"></a>[1. 同步](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 容器?id=_1-同步)</h5><p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h5 id="2-扩容-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-2-扩容-1"><a href="/2019/10/20/Java高级/#2-扩容-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-2-扩容-1" class="headerlink" title="[2. 扩容](https://cyc2018.github.io/CS-Notes/#/notes/Java 容器?id=_2-扩容-1)"></a>[2. 扩容](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 容器?id=_2-扩容-1)</h5><p>Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>调用没有 capacityIncrement 的构造函数时，capacityIncrement 值被设置为 0，也就是说默认情况下 Vector 每次扩容时容量都会翻倍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h5 id="3-与-ArrayList-的比较-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-3-与-arraylist-的比较"><a href="/2019/10/20/Java高级/#3-与-ArrayList-的比较-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-3-与-arraylist-的比较" class="headerlink" title="[3. 与 ArrayList 的比较](https://cyc2018.github.io/CS-Notes/#/notes/Java 容器?id=_3-与-arraylist-的比较)"></a>[3. 与 ArrayList 的比较](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 容器?id=_3-与-arraylist-的比较)</h5><ul>
<li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li>
<li>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。</li>
</ul>
<h5 id="4-替代方案-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-4-替代方案"><a href="/2019/10/20/Java高级/#4-替代方案-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-4-替代方案" class="headerlink" title="[4. 替代方案](https://cyc2018.github.io/CS-Notes/#/notes/Java 容器?id=_4-替代方案)"></a>[4. 替代方案](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 容器?id=_4-替代方案)</h5><p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; synList = Collections.synchronizedList(list);Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>



<h4 id="CopyOnWriteList"><a href="/2019/10/20/Java高级/#CopyOnWriteList" class="headerlink" title="CopyOnWriteList"></a>CopyOnWriteList</h4><h4 id="读写分离"><a href="/2019/10/20/Java高级/#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p>
<p><strong>写操作需要加锁，防止并发写入时导致写入数据丢失。</strong></p>
<p>写操作结束之后需要把原始数组指向新的复制数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="适用场景-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-适用场景"><a href="/2019/10/20/Java高级/#适用场景-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-适用场景" class="headerlink" title="[适用场景](https://cyc2018.github.io/CS-Notes/#/notes/Java 容器?id=适用场景)"></a>[适用场景](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 容器?id=适用场景)</h3><p>CopyOnWriteArrayList 在<strong>写操作的同时允许读操作</strong>，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p>
<p>但是 CopyOnWriteArrayList 有其缺陷：</p>
<ul>
<li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li>
</ul>
<p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p>
<h2 id="JVM"><a href="/2019/10/20/Java高级/#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="Java内存模型"><a href="/2019/10/20/Java高级/#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><blockquote>
<p> Java 内存模型<strong>试图屏蔽各种硬件和操作系统的内存访问差异</strong>，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。 </p>
</blockquote>
<h4 id="主内存与工作内存"><a href="/2019/10/20/Java高级/#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h4><blockquote>
<p> 处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。 </p>
</blockquote>
<p>加入高速缓存带来了一个新的问题：缓存一致性。如果<strong>多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致</strong>，需要一些协议来解决这个问题。</p>
 <img src="/2019/10/20/Java高级//942ca0d2-9d5c-45a4-89cb-5fd89b61913f.png" alt="img" style="zoom: 50%;"> 

<p> <strong>所有的变量都存储在主内存中，每个线程还有自己的工作内存</strong>，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。  <strong>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成</strong> (共享内存)</p>
<h4 id="内存间交互操作"><a href="/2019/10/20/Java高级/#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h4><p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。</p>
<img src="/2019/10/20/Java高级//8b7ebbad-9604-4375-84e3-f412099d170c.png" alt="img" style="zoom: 50%;">



<ul>
<li><strong>read</strong>：把一个变量的值从主内存传输到工作内存中</li>
<li><strong>load</strong>：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li>
<li>use：把工作内存中一个变量的值传递给执行引擎</li>
<li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li>
<li><strong>store</strong>：把工作内存的一个变量的值传送到主内存中</li>
<li><strong>write</strong>：在 store 之后执行，把 store 得到的值放入主内存的变量中</li>
<li><strong>lock</strong>：作用于主内存的变量</li>
<li><strong>unlock</strong>: 作用于主内存的变量</li>
</ul>
<h3 id="内存模型三大特性"><a href="/2019/10/20/Java高级/#内存模型三大特性" class="headerlink" title="内存模型三大特性"></a>内存模型三大特性</h3><h4 id="1-原子性"><a href="/2019/10/20/Java高级/#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h4><p><strong>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性</strong>，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 <strong>volatile(可见性,立即同步)</strong> 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。</p>
<p>有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。</p>
<p>为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。</p>
<p>下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 <strong>T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值</strong>。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 <strong>load、assign、store 这些单个操作具备原子性</strong>。</p>
<img src="/2019/10/20/Java高级//2797a609-68db-4d7b-8701-41ac9a34b14f.jpg" alt="img" style="zoom:50%;">



<p>AtomicInteger 能保证多个线程修改的原子性。</p>
<img src="/2019/10/20/Java高级//dd563037-fcaa-4bd8-83b6-b39d93a12c77.jpg" alt="img" style="zoom:50%;">



<p>使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger cnt = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。<strong>它对应的内存间交互操作为：lock 和 unlock</strong>，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicSynchronizedExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-可见性"><a href="/2019/10/20/Java高级/#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h4><p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。</p>
<p>主要有三种实现可见性的方式：</p>
<ul>
<li>volatile</li>
<li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li>
<li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</li>
</ul>
<p>对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。</p>
<h4 id="3-有序性"><a href="/2019/10/20/Java高级/#3-有序性" class="headerlink" title="3. 有序性"></a>3. 有序性</h4><p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，<strong>重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</strong></p>
<p>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即<strong>重排序时不能把后面的指令放到内存屏障之前。</strong></p>
<p>也<strong>可以通过 synchronized 来保证有序性</strong>，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。</p>
<h3 id="先行发生原则"><a href="/2019/10/20/Java高级/#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p>
<h4 id="1-单一线程原则"><a href="/2019/10/20/Java高级/#1-单一线程原则" class="headerlink" title="1. 单一线程原则"></a>1. 单一线程原则</h4><blockquote>
<p>Single Thread rule</p>
</blockquote>
<p>在一个线程内，在程序前面的操作先行发生于后面的操作。</p>
<img src="/2019/10/20/Java高级//874b3ff7-7c5c-4e7a-b8ab-a82a3e038d20.png" alt="img" style="zoom:67%;">

<h4 id="管程锁定规则"><a href="/2019/10/20/Java高级/#管程锁定规则" class="headerlink" title="管程锁定规则"></a>管程锁定规则</h4><blockquote>
<p>Monitor Lock Rule</p>
</blockquote>
<p>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</p>
<img src="/2019/10/20/Java高级//8996a537-7c4a-4ec8-a3b7-7ef1798eae26.png" alt="img" style="zoom:67%;">

<h4 id="3-volatile-变量规则"><a href="/2019/10/20/Java高级/#3-volatile-变量规则" class="headerlink" title="3. volatile 变量规则"></a>3. volatile 变量规则</h4><blockquote>
<p>Volatile Variable Rule</p>
</blockquote>
<p>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</p>
<img src="/2019/10/20/Java高级//942f33c9-8ad9-4987-836f-007de4c21de0.png" alt="img" style="zoom:67%;">

<h4 id="4-线程启动规则"><a href="/2019/10/20/Java高级/#4-线程启动规则" class="headerlink" title="4. 线程启动规则"></a>4. 线程启动规则</h4><blockquote>
<p>Thread Start Rule</p>
</blockquote>
<p>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</p>
<img src="/2019/10/20/Java高级//6270c216-7ec0-4db7-94de-0003bce37cd2.png" alt="img" style="zoom:67%;">

<h4 id="5-线程加入规则"><a href="/2019/10/20/Java高级/#5-线程加入规则" class="headerlink" title="5. 线程加入规则"></a>5. 线程加入规则</h4><blockquote>
<p>Thread Join Rule</p>
</blockquote>
<p>Thread 对象的结束先行发生于 join() 方法返回。</p>
<img src="/2019/10/20/Java高级//233f8d89-31d7-413f-9c02-042f19c46ba1.png" alt="img" style="zoom:67%;">

<h4 id="6-线程中断规则"><a href="/2019/10/20/Java高级/#6-线程中断规则" class="headerlink" title="6. 线程中断规则"></a>6. 线程中断规则</h4><blockquote>
<p>Thread Interruption Rule</p>
</blockquote>
<p>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</p>
<h4 id="7-对象终结规则"><a href="/2019/10/20/Java高级/#7-对象终结规则" class="headerlink" title="[7. 对象终结规则"></a>[7. 对象终结规则</h4><blockquote>
<p>Finalizer Rule</p>
</blockquote>
<p>一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</p>
<h4 id="8-传递性"><a href="/2019/10/20/Java高级/#8-传递性" class="headerlink" title="8. 传递性"></a>8. 传递性</h4><blockquote>
<p>Transitivity</p>
</blockquote>
<p>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</p>
<h3 id="内存分区"><a href="/2019/10/20/Java高级/#内存分区" class="headerlink" title="内存分区"></a>内存分区</h3><p><strong>内存分区:</strong> (总共分为: <strong>程序计数器, 堆, 栈, 方法区, 本地方法区</strong>)</p>
<ul>
<li><p><strong>线程私有区域:程序计数器、Java虚拟机栈、本地方法栈</strong></p>
<p>如果当前线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行 的是一个Native方法，这个计数器值为空。</p>
</li>
<li><p><strong>线程共享区域:Java堆(存储静态文件, 变量) , 方法区、运行时常量池</strong></p>
</li>
</ul>
<p><u><strong>当线程终止时，三者（虚拟机栈，本地方法栈和程序计数器）所占用的内存空间也会被释放掉, 因为它们是非共享区</strong></u></p>
<img src="/2019/10/20/Java高级//1216886-20170829193405046-797335140.png" alt="img" style="zoom: 67%;">

<h4 id="内存溢出"><a href="/2019/10/20/Java高级/#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><p><strong>原因:</strong>系统不能再分配你所需的内存空间</p>
<ol>
<li>一次性加载了过多的数据</li>
<li>对象不能被回收</li>
<li>代码bug导致死循环</li>
</ol>
<p>解决方案:</p>
<ol>
<li>使用内存分析工具jstat分析原因</li>
<li>调式是否是三方软件的漏洞</li>
<li>设置启动内存的大小</li>
</ol>
<h4 id="内存泄漏"><a href="/2019/10/20/Java高级/#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p><strong>原因:</strong>内存中有一块空间无法在被使用,又不能被清理掉,累积量大了之后就会导致内存泄漏</p>
<ol>
<li>代码漏洞导致常发性或者偶发性泄漏</li>
<li>对象不能被回收是根本原因</li>
</ol>
<p><strong>内存溢出和内存泄露的联系</strong><br>内存泄露会最终会导致内存溢出。<br>相同点：都会导致应用程序运行出现问题，性能下降或挂起。<br>不同点：</p>
<ul>
<li>1) 内存泄露是导致内存溢出的原因之一，内存泄露积累起来将导致内存溢出。</li>
<li>2) 内存泄露可以通过完善代码来避免，内</li>
</ul>
<h2 id="GC"><a href="/2019/10/20/Java高级/#GC" class="headerlink" title="GC"></a>GC</h2><h3 id="GC算法和机制"><a href="/2019/10/20/Java高级/#GC算法和机制" class="headerlink" title="GC算法和机制"></a>GC算法和机制</h3><ul>
<li><strong>机制</strong>: 标记清除, 引用计数, 停止-复制(程序暂停执行)</li>
<li><strong>算法</strong>: 引用计数法, 根搜索算法, 标记-清除算法, 复制算法 Copying, 标记整理算法</li>
</ul>
<h3 id="GC算法"><a href="/2019/10/20/Java高级/#GC算法" class="headerlink" title="GC算法"></a>GC算法</h3><p>java语言规范没有明确的说明JVM 使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做两件基本事情：</p>
<p>（1）发现无用的信息对象；</p>
<p>（2）回收将无用对象占用的内存空间。使该空间可被程序再次使用。</p>
<h4 id="1-引用计数法"><a href="/2019/10/20/Java高级/#1-引用计数法" class="headerlink" title="1. 引用计数法"></a>1. 引用计数法</h4><p>堆中每个对象实例都有一个引用计数。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。</p>
<h6 id="优点"><a href="/2019/10/20/Java高级/#优点" class="headerlink" title="优点:"></a>优点:</h6><p>引用计数器可以很快的额执行, 交织在程序运行中,对程序需要不被长时间打断的<strong>实时环境比较有利</strong></p>
<h6 id="缺点"><a href="/2019/10/20/Java高级/#缺点" class="headerlink" title="缺点:"></a>缺点:</h6><p>无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyObject object1 = <span class="keyword">new</span> MyObject();</span><br><span class="line">        MyObject object2 = <span class="keyword">new</span> MyObject();</span><br><span class="line">          </span><br><span class="line">        object1.object = object2;</span><br><span class="line">        object2.object = object1;</span><br><span class="line">          </span><br><span class="line">        object1 = <span class="keyword">null</span>;</span><br><span class="line">        object2 = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-tracing算法-Tracing-Collector-或-标记-清除算法-mark-and-sweep"><a href="/2019/10/20/Java高级/#2-tracing算法-Tracing-Collector-或-标记-清除算法-mark-and-sweep" class="headerlink" title="2. tracing算法(Tracing Collector) 或 标记-清除算法(mark and sweep)"></a>2. tracing算法(Tracing Collector) 或 标记-清除算法(mark and sweep)</h4><img src="/2019/10/20/Java高级//7178f37egw1etbmyb4jugj20ku0ajmy0.jpg" alt="img" style="zoom:67%;">

<p>从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。</p>
<p><strong>java中可作为GC Root的对象有</strong></p>
<p>1.虚拟机栈中引用的对象（本地变量表）</p>
<p>2.方法区中静态属性引用的对象</p>
<p>3.方法区中常量引用的对象</p>
<p>4.本地方法栈中引用的对象（Native对象)</p>
<h5 id="2-2-1-标记-清除算法"><a href="/2019/10/20/Java高级/#2-2-1-标记-清除算法" class="headerlink" title="2.2.1 标记-清除算法"></a>2.2.1 标记-清除算法</h5><p>标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如图所示</p>
<img src="/2019/10/20/Java高级//7178f37egw1etbmyakm6pj20fi0crmxm.jpg" alt="img" style="zoom:67%;">

<h5 id="2-2-2-compacting算法-或-标记-整理算法"><a href="/2019/10/20/Java高级/#2-2-2-compacting算法-或-标记-整理算法" class="headerlink" title="2.2.2 compacting算法 或 标记-整理算法"></a>2.2.2 compacting算法 或 标记-整理算法</h5><p>标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，<strong>会将所有的存活对象往左端空闲空间移动</strong>，并更新对应的指针,解决了内存碎片的问题.</p>
<h5 id="2-2-3copying算法-Compacting-Collector"><a href="/2019/10/20/Java高级/#2-2-3copying算法-Compacting-Collector" class="headerlink" title="2.2.3copying算法(Compacting Collector)"></a>2.2.3copying算法(Compacting Collector)</h5><p>基于copying算法的垃圾 收集就从根集中<strong>扫描活动对象</strong>，并将每个 <strong>活动对象复制到空闲面</strong>(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象面和空闲区域面，在对象面与空闲区域面的切换过程中，==程序暂停执行==。</p>
<h5 id="2-3-4-generation算法-Generational-Collector-分代回收"><a href="/2019/10/20/Java高级/#2-3-4-generation算法-Generational-Collector-分代回收" class="headerlink" title="2.3.4 generation算法(Generational Collector)分代回收"></a>2.3.4 generation算法(Generational Collector)分代回收</h5><p>分代的垃圾回收策略，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的</strong>。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。</p>
<img src="/2019/10/20/Java高级//7178f37egw1etbmycakylj20fn08kgmb.jpg" alt="img" style="zoom:67%;">



<p>Java中的对是jvm所管理的最大的一块内存空间, 主要用于粗放各种类的实例对象.</p>
<p>在Java中堆被分成两个不同的区域: </p>
<p><strong>1. 新生代(young)</strong></p>
<blockquote>
<p>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。</p>
</blockquote>
<p><strong>存在区域</strong>:Eden, From Survivor, To Survivor</p>
<p>回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。</p>
<p>当<strong>survivor1区不足</strong>以存放 eden和survivor0的存活对象时，就<strong>将存活对象直接存放到老年代</strong>。若是<strong>老年代</strong>也<strong>满了</strong>就会<strong>触发</strong>一次<strong>Full GC</strong>，也就是==新生代、老年代都进行回收==</p>
<p><strong>2. 老年代(old)</strong></p>
<blockquote>
<p>在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p>
</blockquote>
<p>当<strong>老年代内存满时触发Major GC即Full GC</strong>，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。</p>
<img src="http://www.blogjava.net/images/blogjava_net/fancydeepin/JVM/%E5%A0%86%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B2.png" alt="img" style="zoom: 67%;">

<p>堆大小=新生代+老年代,  堆的大小可以通过参数 –Xms、-Xmx 来指定。</p>
<p><strong>JVM</strong> 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。<br>因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。</p>
<ol start="3">
<li><p>持久代（Permanent Generation）</p>
<p>用于存放<strong>静态文件</strong>，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。</p>
</li>
</ol>
<h3 id="GC（垃圾收集器）"><a href="/2019/10/20/Java高级/#GC（垃圾收集器）" class="headerlink" title="GC（垃圾收集器）"></a>GC（垃圾收集器）</h3><img src="/2019/10/20/Java高级//7178f37egw1etbmycjfvoj20e40engmi.jpg" alt="img" style="zoom:67%;">

<ul>
<li><p><strong>Serial收集器（复制算法)</strong></p>
<p>新生代单线程收集器，标记和清理都是单线程，优点是简单高效。</p>
</li>
<li><p><strong>Serial Old收集器(标记-整理算法)</strong></p>
<p>老年代单线程收集器，Serial收集器的老年代版本。</p>
</li>
<li><p><strong>ParNew收集器(停止-复制算法)</strong>　</p>
<p>新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。</p>
</li>
<li><p><strong>Parallel Scavenge收集器(停止-复制算法)</strong></p>
<p>并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。</p>
</li>
<li><p><strong>Parallel Old收集器(停止-复制算法)</strong></p>
<p>Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先</p>
</li>
<li><p><strong>CMS(Concurrent Mark Sweep)收集器（标记-清理算法）</strong></p>
<p>高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择</p>
</li>
</ul>
<h3 id="GC的执行机制"><a href="/2019/10/20/Java高级/#GC的执行机制" class="headerlink" title="GC的执行机制"></a>GC的执行机制</h3><p>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。</p>
<ul>
<li><h5 id="Scavenge-GC"><a href="/2019/10/20/Java高级/#Scavenge-GC" class="headerlink" title="Scavenge GC"></a><strong>Scavenge GC</strong></h5><p>一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p>
</li>
<li><h5 id="Full-GC"><a href="/2019/10/20/Java高级/#Full-GC" class="headerlink" title="Full GC"></a><strong>Full GC</strong></h5><p>对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：</p>
<ul>
<li>1.年老代（Tenured）被写满</li>
<li>2.持久代（Perm）被写满</li>
<li>3.<strong>System.gc()</strong>被显示调用</li>
<li>4.上一次GC之后Heap的各域分配策略动态变化</li>
</ul>
</li>
</ul>
<h3 id="Java有了GC同样会出现内存泄露问题"><a href="/2019/10/20/Java高级/#Java有了GC同样会出现内存泄露问题" class="headerlink" title="Java有了GC同样会出现内存泄露问题"></a>Java有了GC同样会出现内存泄露问题</h3><ul>
<li>1.静态集合类像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放，因为他们也将一直被Vector等应用着。</li>
<li>2.各种连接，数据库连接，网络连接，IO连接等没有显示调用close关闭，不被GC回收导致内存泄露。</li>
<li>3.监听器的使用，在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露。</li>
</ul>
<h3 id="JVM中的安全点"><a href="/2019/10/20/Java高级/#JVM中的安全点" class="headerlink" title="JVM中的安全点"></a>JVM中的安全点</h3><blockquote>
<h4 id="在-JVM-中如何判断对象可以被回收-一文中，我们知道-HotSpot-虚拟机采取的是可达性分析算法。即通过-GC-Roots-枚举判定待回收的对象。"><a href="/2019/10/20/Java高级/#在-JVM-中如何判断对象可以被回收-一文中，我们知道-HotSpot-虚拟机采取的是可达性分析算法。即通过-GC-Roots-枚举判定待回收的对象。" class="headerlink" title="在 JVM 中如何判断对象可以被回收 一文中，我们知道 HotSpot 虚拟机采取的是可达性分析算法。即通过 GC Roots 枚举判定待回收的对象。"></a>在 JVM 中如何判断对象可以被回收 一文中，我们知道 HotSpot 虚拟机采取的是可达性分析算法。即通过 GC Roots 枚举判定待回收的对象。</h4></blockquote>
<p>那么，首先要找到哪些是 GC Roots。</p>
<p>有两种查找 GC Roots 的方法：</p>
<ul>
<li>一种是遍历方法区和栈区查找（保守式 GC）。</li>
<li>一种是通过 OopMap 数据结构来记录 GC Roots 的位置（准确式 GC）。</li>
</ul>
<p>很明显，保守式 GC 的成本太高。准确式 GC 的优点就是能够让虚拟机快速定位到 GC Roots。</p>
<p>对应 OopMap 的位置即可作为一个安全点（Safe Point）。</p>
<p>在执行 GC 操作时，所有的工作线程必须停顿，这就是所谓的”Stop-The-World”。</p>
<p>为什么呢？</p>
<p>因为可达性分析算法必须是在一个确保一致性的内存快照中进行。如果在分析的过程中对象引用关系还在不断变化，分析结果的准确性就不能保证。</p>
<p>安全点意味着在这个点时，所有工作线程的状态是确定的，JVM 就可以安全地执行 GC 。</p>
<h3 id="如何选定安全点"><a href="/2019/10/20/Java高级/#如何选定安全点" class="headerlink" title="如何选定安全点"></a>如何选定安全点</h3><p>安全点太多，GC 过于频繁，增大运行时负荷；安全点太少，GC 等待时间太长。</p>
<p>一般会在如下几个位置选择安全点：</p>
<ul>
<li>循环的末尾</li>
<li>方法临返回前</li>
<li>调用方法之后</li>
<li>抛异常的位置</li>
</ul>
<p><strong>为什么选定这些位置作为安全点：</strong></p>
<p>主要的目的就是<strong>避免程序长时间无法进入 Safe Point</strong>。比如 JVM 在做 GC 之前要等所有的应用线程进入安全点，如果有一个线程一直没有进入安全点，就会<strong>导致 GC 时 JVM 停顿时间延长</strong>。比如这里，超大的循环导致执行 GC 等待时间过长。</p>
<h3 id="如何在-GC-发生时，所有线程都跑到最近的-Safe-Point-上再停下来？"><a href="/2019/10/20/Java高级/#如何在-GC-发生时，所有线程都跑到最近的-Safe-Point-上再停下来？" class="headerlink" title="如何在 GC 发生时，所有线程都跑到最近的 Safe Point 上再停下来？"></a>如何在 GC 发生时，所有线程都跑到最近的 Safe Point 上再停下来？</h3><p>主要有两种方式：</p>
<ul>
<li>抢断式中断：在 GC 发生时，首先中断所有线程，如果发现线程未执行到 Safe Point，就恢复线程让其运行到 Safe Point 上。</li>
<li>主动式中断：在 GC 发生时，不直接操作线程中断，而是简单地设置一个标志，让各个线程执行时主动轮询这个标志，发现中断标志为真时就自己中断挂起。</li>
</ul>
<p><u>JVM 采取的就是<strong>主动式中断</strong></u>。轮询标志的地方和安全点是重合的。</p>
<h3 id="安全区域又是什么？"><a href="/2019/10/20/Java高级/#安全区域又是什么？" class="headerlink" title="安全区域又是什么？"></a>安全区域又是什么？</h3><p>Safe Point 是对正在执行的线程设定的, 如果<strong>一个线程处于 Sleep 或中断状态，它就不能响应 JVM 的中断请求</strong>，再运行到 Safe Point 上。因此 JVM 引入了 Safe Region。</p>
<p>Safe Region 是指在一段代码片段中，引用关系不会发生变化。在这个区域内的任意地方开始 GC 都是安全的。线程在进入 Safe Region 的时候先标记自己已进入了 Safe Region，等到被唤醒时准备离开 Safe Region 时，先检查能否离开，如果 GC 完成了，那么线程可以离开，否则它必须等待直到收到安全离开的信号为止。</p>

      </div>
      
        <br>
        


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-10-20T21:47:17+08:00">
  <a class='notlink'>
    <i class="fas fa-clock" aria-hidden="true"></i>
    <p>updated at Oct 20, 2019</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Java/" rel="nofollow"><i class="fas fa-tag" aria-hidden="true"></i><p>Java</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/IT/" rel="nofollow"><i class="fas fa-tag" aria-hidden="true"></i><p>IT</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" rel="nofollow"><i class="fas fa-tag" aria-hidden="true"></i><p>技术笔记</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Job/" rel="nofollow"><i class="fas fa-tag" aria-hidden="true"></i><p>Job</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="QQ好友" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=/2019/10/20/Java%E9%AB%98%E7%BA%A7/&title=Java高级核心 | 蜗牛君&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="QQ空间" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=/2019/10/20/Java%E9%AB%98%E7%BA%A7/&title=Java高级核心 | 蜗牛君&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="微博" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=/2019/10/20/Java%E9%AB%98%E7%BA%A7/&title=Java高级核心 | 蜗牛君&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


      
      
          <div class="prev-next">
              
                  <section class="prev">
                      <span class="art-item-left">
                          <h6><i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;Previous</h6>
                          <h4>
                              <a href="/2019/10/20/Mybatis%E9%9D%A2%E8%AF%95/" rel="prev" title="Mybatis面试">
                                
                                    Mybatis面试
                                
                              </a>
                          </h4>
                          
                              
                              <h6 class="tags">
                                  <a class="tag" href="/tags/IT/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> IT</a> <a class="tag" href="/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> 技术笔记</a> <a class="tag" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> 数据库</a> <a class="tag" href="/tags/Job/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> Job</a> <a class="tag" href="/tags/Mybatis/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> Mybatis</a>
                              </h6>
                          
                      </span>
                  </section>
              
              
                  <section class="next">
                      <span class="art-item-right" aria-hidden="true">
                          <h6>Next&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></h6>
                          <h4>
                              <a href="/2019/10/20/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" rel="prev" title="算法笔记">
                                  
                                      算法笔记
                                  
                              </a>
                          </h4>
                          
                              
                              <h6 class="tags">
                                  <a class="tag" href="/tags/IT/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> IT</a> <a class="tag" href="/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> 技术笔记</a> <a class="tag" href="/tags/Job/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> Job</a> <a class="tag" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> 数据结构</a> <a class="tag" href="/tags/%E7%AE%97%E6%B3%95/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> 算法</a> <a class="tag" href="/tags/%E6%8E%92%E5%BA%8F/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> 排序</a>
                              </h6>
                          
                      </span>
                  </section>
              
          </div>
      
    </section>
  </article>



  <!-- 显示推荐文章和评论 -->



  <article class="post white-box comments">
    <section class="article typo">
      <h4><i class="fas fa-comments fa-fw" aria-hidden="true"></i>&nbsp;Comments</h4>
      
      
      
        <section id="comments">
          <div id="gitalk-container"></div>
        </section>
      
      
    </section>
  </article>






<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: 'Java高级核心',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
    
    
      
      
        
          
          
            
              <section class='widget author'>
  <div class='content pure'>
    
      <div class='avatar'>
        <img class='avatar' src='/assets/self.jpg'/>
      </div>
    
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml"
              class="social fas fa-rss flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:dmlys@live.com"
              class="social fas fa-envelope flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/ChanMango"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=118376074"
              class="social fas fa-headphones-alt flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

            
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
            
              
  <section class='widget toc-wrapper'>
    
<header class='pure'>
  <div><i class="fas fa-list fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;TOC</div>
  
    <!-- <div class='wrapper'><a class="s-toc rightBtn" rel="external nofollow noopener noreferrer" href="javascript:void(0)"><i class="fas fa-thumbtack fa-fw"></i></a></div> -->
  
</header>

    <div class='content pure'>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#队列"><span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#等待队列（Condition-Queue）"><span class="toc-text">等待队列（Condition Queue）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockingQueue"><span class="toc-text">BlockingQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见BlockingQueue"><span class="toc-text">常见BlockingQueue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设计模式"><span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#设计模式的六大原则及其含义"><span class="toc-text">设计模式的六大原则及其含义:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见模式及优缺点："><span class="toc-text">常见模式及优缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设计模式在实际场景的应用"><span class="toc-text">设计模式在实际场景的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring中用到了哪些设计模式"><span class="toc-text">==Spring中用到了哪些设计模式==</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis中用到了哪些设计模式"><span class="toc-text">==MyBatis中用到了哪些设计模式==</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代理模式-Proxy"><span class="toc-text">代理模式(Proxy)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类加载器"><span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ClassLoader"><span class="toc-text">ClassLoader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#来看看-loadClass-方法的代码：双亲委托机制"><span class="toc-text">来看看 loadClass 方法的代码：双亲委托机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO"><span class="toc-text">IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java的io，nio，bio区别"><span class="toc-text">Java的io，nio，bio区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-模型"><span class="toc-text">I/O 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#阻塞式-I-O"><span class="toc-text">阻塞式 I/O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#非阻塞式-I-O"><span class="toc-text">非阻塞式 I/O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O-复用"><span class="toc-text">I/O 复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#信号驱动-I-O"><span class="toc-text">信号驱动 I/O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异步-I-O-AIO"><span class="toc-text">异步 I/O (AIO)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#五大-I-O-模型比较"><span class="toc-text">五大 I/O 模型比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O-复用-详细讲解"><span class="toc-text">I/O 复用 详细讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#select"><span class="toc-text">select</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#poll"><span class="toc-text">poll</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#比较"><span class="toc-text">比较</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-功能"><span class="toc-text">1. 功能</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-速度"><span class="toc-text">2. 速度</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-可移植性"><span class="toc-text">3. 可移植性</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#epoll"><span class="toc-text">epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#工作模式"><span class="toc-text">工作模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#应用场景"><span class="toc-text">应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-select-应用场景"><span class="toc-text">1. select 应用场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-poll-应用场景"><span class="toc-text">2. poll 应用场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-epoll-应用场景"><span class="toc-text">3. epoll 应用场景</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程"><span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程和线程区别"><span class="toc-text">进程和线程区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#守护线程-amp-非守护线程"><span class="toc-text">守护线程&amp;非守护线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的状态转换"><span class="toc-text">线程的状态转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程安全"><span class="toc-text">线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要用线程池"><span class="toc-text">为什么要用线程池?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#线程中重要的几个类"><span class="toc-text">线程中重要的几个类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-Thread的弊端"><span class="toc-text">new Thread的弊端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java提供的四种线程池的好处在于："><span class="toc-text">Java提供的四种线程池的好处在于：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四种线程池"><span class="toc-text">四种线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#submit-和execute-的以及shutdown-和shutdownNow-的区别"><span class="toc-text">submit()和execute()的以及shutdown()和shutdownNow()的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RejectedExecutionHandler-线程池四种拒绝任务策略"><span class="toc-text">RejectedExecutionHandler 线程池四种拒绝任务策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Runnable-Callable-Future和-FutureTask"><span class="toc-text">Runnable, Callable, Future和 FutureTask</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Callable与Runnable"><span class="toc-text">Callable与Runnable</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Future"><span class="toc-text">Future</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FutureTask"><span class="toc-text">FutureTask</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁"><span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁的原因"><span class="toc-text">死锁的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS"><span class="toc-text">CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CAS导致的问题"><span class="toc-text">CAS导致的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized、volatile的区别"><span class="toc-text">synchronized、volatile的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Volatile"><span class="toc-text">Volatile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized"><span class="toc-text">synchronized</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized和CAS区别"><span class="toc-text">Synchronized和CAS区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock"><span class="toc-text">ReentrantLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#偏向锁-jvm内部"><span class="toc-text">偏向锁(jvm内部)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#轻量级锁-jvm"><span class="toc-text">轻量级锁(jvm)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自旋锁-jvm"><span class="toc-text">自旋锁(jvm)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jvm内部对锁的操作"><span class="toc-text">jvm内部对锁的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized实现，lock实现，有何区别"><span class="toc-text">synchronized实现，lock实现，有何区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JUC"><span class="toc-text">JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#J-U-C-AQS"><span class="toc-text">J.U.C - AQS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CountDownLatch"><span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CyclicBarrier"><span class="toc-text">CyclicBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Semaphore"><span class="toc-text">Semaphore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本类型原子类"><span class="toc-text">基本类型原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发容器"><span class="toc-text">并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap"><span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashTable"><span class="toc-text">HashTable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector"><span class="toc-text">Vector</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-同步-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-1-同步"><span class="toc-text">[1. 同步](https://cyc2018.github.io/CS-Notes/#/notes/Java 容器?id=_1-同步)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-扩容-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-2-扩容-1"><span class="toc-text">[2. 扩容](https://cyc2018.github.io/CS-Notes/#/notes/Java 容器?id=_2-扩容-1)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-与-ArrayList-的比较-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-3-与-arraylist-的比较"><span class="toc-text">[3. 与 ArrayList 的比较](https://cyc2018.github.io/CS-Notes/#/notes/Java 容器?id=_3-与-arraylist-的比较)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-替代方案-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-4-替代方案"><span class="toc-text">[4. 替代方案](https://cyc2018.github.io/CS-Notes/#/notes/Java 容器?id=_4-替代方案)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CopyOnWriteList"><span class="toc-text">CopyOnWriteList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读写分离"><span class="toc-text">读写分离</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#适用场景-https-cyc2018-github-io-CS-Notes-notes-Java-容器-id-适用场景"><span class="toc-text">[适用场景](https://cyc2018.github.io/CS-Notes/#/notes/Java 容器?id=适用场景)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java内存模型"><span class="toc-text">Java内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主内存与工作内存"><span class="toc-text">主内存与工作内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存间交互操作"><span class="toc-text">内存间交互操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存模型三大特性"><span class="toc-text">内存模型三大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-原子性"><span class="toc-text">1. 原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-可见性"><span class="toc-text">2. 可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-有序性"><span class="toc-text">3. 有序性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#先行发生原则"><span class="toc-text">先行发生原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-单一线程原则"><span class="toc-text">1. 单一线程原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#管程锁定规则"><span class="toc-text">管程锁定规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-volatile-变量规则"><span class="toc-text">3. volatile 变量规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-线程启动规则"><span class="toc-text">4. 线程启动规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-线程加入规则"><span class="toc-text">5. 线程加入规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-线程中断规则"><span class="toc-text">6. 线程中断规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-对象终结规则"><span class="toc-text">[7. 对象终结规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-传递性"><span class="toc-text">8. 传递性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存分区"><span class="toc-text">内存分区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#内存溢出"><span class="toc-text">内存溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存泄漏"><span class="toc-text">内存泄漏</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC"><span class="toc-text">GC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GC算法和机制"><span class="toc-text">GC算法和机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC算法"><span class="toc-text">GC算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-引用计数法"><span class="toc-text">1. 引用计数法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#优点"><span class="toc-text">优点:</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#缺点"><span class="toc-text">缺点:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-tracing算法-Tracing-Collector-或-标记-清除算法-mark-and-sweep"><span class="toc-text">2. tracing算法(Tracing Collector) 或 标记-清除算法(mark and sweep)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1-标记-清除算法"><span class="toc-text">2.2.1 标记-清除算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-2-compacting算法-或-标记-整理算法"><span class="toc-text">2.2.2 compacting算法 或 标记-整理算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-3copying算法-Compacting-Collector"><span class="toc-text">2.2.3copying算法(Compacting Collector)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-4-generation算法-Generational-Collector-分代回收"><span class="toc-text">2.3.4 generation算法(Generational Collector)分代回收</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC（垃圾收集器）"><span class="toc-text">GC（垃圾收集器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC的执行机制"><span class="toc-text">GC的执行机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Scavenge-GC"><span class="toc-text">Scavenge GC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Full-GC"><span class="toc-text">Full GC</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java有了GC同样会出现内存泄露问题"><span class="toc-text">Java有了GC同样会出现内存泄露问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM中的安全点"><span class="toc-text">JVM中的安全点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#在-JVM-中如何判断对象可以被回收-一文中，我们知道-HotSpot-虚拟机采取的是可达性分析算法。即通过-GC-Roots-枚举判定待回收的对象。"><span class="toc-text">在 JVM 中如何判断对象可以被回收 一文中，我们知道 HotSpot 虚拟机采取的是可达性分析算法。即通过 GC Roots 枚举判定待回收的对象。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何选定安全点"><span class="toc-text">如何选定安全点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何在-GC-发生时，所有线程都跑到最近的-Safe-Point-上再停下来？"><span class="toc-text">如何在 GC 发生时，所有线程都跑到最近的 Safe Point 上再停下来？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安全区域又是什么？"><span class="toc-text">安全区域又是什么？</span></a></li></ol></li></ol>
    </div>
  </section>


            
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
            
              <section class='widget grid'>
  
<header class='pure'>
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class='content pure'>
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="/" href="/"
          
          
          id="home">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="/archives/" href="/archives/"
          
            rel="nofollow"
          
          
          id="archives">
          
            <i class="fas fa-archive fa-fw" aria-hidden="true"></i>
          
          文章归档
        </a></li>
      
        <li><a class="flat-box" title="/about/" href="/about/"
          
            rel="nofollow"
          
          
          id="about">
          
            <i class="fas fa-info-circle fa-fw" aria-hidden="true"></i>
          
          关于小站
        </a></li>
      
    </ul>
  </div>
</section>

            
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
            
              
  <section class='widget category'>
    
<header class='pure'>
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;Categories</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/categories/"
    title="categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/Docker/" href="/categories/Docker/"><div class='name'>Docker</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child" title="/categories/Docker/Mysql/" href="/categories/Docker/Mysql/"><div class='name'>Mysql</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Java/" href="/categories/Java/"><div class='name'>Java</div><div class='badge'>(8)</div></a></li>
        
          <li><a class="flat-box child" title="/categories/Java/ReentrantLock/" href="/categories/Java/ReentrantLock/"><div class='name'>ReentrantLock</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/categories/Java/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" href="/categories/Java/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"><div class='name'>代理模式</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/categories/Java/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/" href="/categories/Java/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"><div class='name'>基本类型</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Linux/" href="/categories/Linux/"><div class='name'>Linux</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/MySQL/" href="/categories/MySQL/"><div class='name'>MySQL</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/categories/MySQL/Docker/" href="/categories/MySQL/Docker/"><div class='name'>Docker</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Mysql/" href="/categories/Mysql/"><div class='name'>Mysql</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/docker/" href="/categories/docker/"><div class='name'>docker</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child" title="/categories/docker/Jenkins/" href="/categories/docker/Jenkins/"><div class='name'>Jenkins</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/git/" href="/categories/git/"><div class='name'>git</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/mysql/" href="/categories/mysql/"><div class='name'>mysql</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/categories/mysql/%E5%AD%97%E7%AC%A6%E4%B9%B1%E7%A0%81/" href="/categories/mysql/%E5%AD%97%E7%AC%A6%E4%B9%B1%E7%A0%81/"><div class='name'>字符乱码</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/spribgboot/" href="/categories/spribgboot/"><div class='name'>spribgboot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/%E5%81%A5%E8%BA%AB/" href="/categories/%E5%81%A5%E8%BA%AB/"><div class='name'>健身</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"><div class='name'>分布式</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><div class='name'>数据结构</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"><div class='name'>算法</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/%E7%BC%93%E5%AD%98/" href="/categories/%E7%BC%93%E5%AD%98/"><div class='name'>缓存</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/" href="/categories/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/"><div class='name'>英语语法</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><div class='name'>计算机网络</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/%E9%9D%A2%E8%AF%95/" href="/categories/%E9%9D%A2%E8%AF%95/"><div class='name'>面试</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/categories/%E9%9D%A2%E8%AF%95/Java/" href="/categories/%E9%9D%A2%E8%AF%95/Java/"><div class='name'>Java</div><div class='badge'>(1)</div></a></li>
        
      </ul>
    </div>
  </section>


            
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
            
              
  <section class='widget tagcloud'>
    
<header class='pure'>
  <div><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;Hot Tags</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/tags/"
    title="tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <a href="/tags/Jenkins-docker/" style="font-size: 14px; color: #999">-Jenkins -docker</a> <a href="/tags/Docker/" style="font-size: 14px; color: #999">Docker</a> <a href="/tags/Hibernate/" style="font-size: 14px; color: #999">Hibernate</a> <a href="/tags/IT/" style="font-size: 22.57px; color: #5f5f5f">IT</a> <a href="/tags/IT-%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0-Job-zookeeper/" style="font-size: 14px; color: #999">IT - 技术笔记 - Job - zookeeper</a> <a href="/tags/Java/" style="font-size: 19.71px; color: #727272">Java</a> <a href="/tags/Job/" style="font-size: 21.14px; color: #686868">Job</a> <a href="/tags/Kafka/" style="font-size: 14px; color: #999">Kafka</a> <a href="/tags/Linux/" style="font-size: 14px; color: #999">Linux</a> <a href="/tags/Lock/" style="font-size: 14px; color: #999">Lock</a> <a href="/tags/MySQL%E9%9B%86%E7%BE%A4/" style="font-size: 14px; color: #999">MySQL集群</a> <a href="/tags/Mybatis/" style="font-size: 14px; color: #999">Mybatis</a> <a href="/tags/Redis/" style="font-size: 14px; color: #999">Redis</a> <a href="/tags/Spring/" style="font-size: 14px; color: #999">Spring</a> <a href="/tags/docker/" style="font-size: 14px; color: #999">docker</a> <a href="/tags/dockerfile/" style="font-size: 14px; color: #999">dockerfile</a> <a href="/tags/java/" style="font-size: 14px; color: #999">java</a> <a href="/tags/mysql/" style="font-size: 18.29px; color: #7c7c7c">mysql</a> <a href="/tags/tomcat/" style="font-size: 15.43px; color: #8f8f8f">tomcat</a> <a href="/tags/zookeeper/" style="font-size: 14px; color: #999">zookeeper</a> <a href="/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" style="font-size: 14px; color: #999">代理模式</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 14px; color: #999">分布式</a> <a href="/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" style="font-size: 24px; color: #555">技术笔记</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 14px; color: #999">排序</a> <a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 14px; color: #999">排序算法</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 16.86px; color: #868686">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 15.43px; color: #8f8f8f">数据结构</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/" style="font-size: 15.43px; color: #8f8f8f">服务端开发</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 14px; color: #999">算法</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 14px; color: #999">缓存</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 14px; color: #999">网络</a> <a href="/tags/%E8%8B%B1%E8%AF%AD/" style="font-size: 15.43px; color: #8f8f8f">英语</a> <a href="/tags/%E9%81%BF%E5%9D%91/" style="font-size: 14px; color: #999">避坑</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 15.43px; color: #8f8f8f">面试</a>
    </div>
  </section>


            
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="/atom.xml"
            class="social fas fa-rss flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="mailto:dmlys@live.com"
            class="social fas fa-envelope flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/ChanMango"
            class="social fab fa-github flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://music.163.com/#/user/home?id=118376074"
            class="social fas fa-headphones-alt flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  <br>
  <div><p>Blog content follows the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
  <div>
    Use
    <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a>
    as theme
    
      , 
      total visits
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      times
    
    . 
  </div>
</footer>
<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>




  
  
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>
    <script type="text/javascript">
      $(function(){
        if ('.cover') {
          $('.cover').backstretch(
          ["assets/cover5.jpg"],
          {
            duration: "6000",
            fade: "2500"
          });
        } else {
          $.backstretch(
          ["assets/cover5.jpg"],
          {
            duration: "6000",
            fade: "2500"
          });
        }
      });
    </script>
  







  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
  <script type="text/javascript">
    var gitalk = new Gitalk({
      clientID: "c0594c9716f6179f3677",
      clientSecret: "c13716fc7d33a328f4d5dc4a1b8a2af3823ed2ac",
      repo: "ChanMango.github.io",
      owner: "ChanMango",
      admin: "蜗牛君",
      
        id: location.pathname,      // Ensure uniqueness and length less than 50
      
      distractionFreeMode: false  // Facebook-like distraction free mode
    });
    gitalk.render('gitalk-container');
  </script>





  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.9/js/app.js"></script>


  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.9/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "Copied";
  let COPY_FAILURE = "Copy failed";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>Copy</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  <script>setLoadingBarProgress(100);</script>
</body>
</html>
